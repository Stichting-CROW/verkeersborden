@prefix bm: <http://www.laces.tech/publication/ns/semmtech/live/laces/schema/blueprint-manager/> .
@prefix bs: <https://w3id.org/def/basicsemantics-owl#> .
@prefix dct: <http://purl.org/dc/terms/> .
@prefix ex: <http://example.org/example#> .
@prefix kos: <http://www.laces.tech/publication/ns/semmtech/live/laces/schema/kos/> .
@prefix nen2660: <https://w3id.org/nen2660/def#> .
@prefix otl: <http://www.laces.tech/publication/ns/semmtech/live/laces/schema/otl-manager/> .
@prefix owl: <http://www.w3.org/2002/07/owl#> .
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .
@prefix schema: <https://schema.org/> .
@prefix sh: <http://www.w3.org/ns/shacl#> .
@prefix shapes: <http://www.laces.tech/publication/ns/semmtech/live/laces/schema/shapes/> .
@prefix skos: <http://www.w3.org/2004/02/skos/core#> .
@prefix specifications: <http://www.laces.tech/publication/ns/semmtech/live/laces/schema/specifications/> .
@prefix xsd: <http://www.w3.org/2001/XMLSchema#> .
@prefix geo: <http://www.opengis.net/ont/geosparql#> .

ex:ConvertAspectWithRole a sh:NodeShape ;
    sh:rule [ a sh:SPARQLRule ;
            sh:construct """	
			CONSTRUCT {
							?tgtAspect a ?tgtPropertyType .
							?tgtAspect rdfs:subPropertyOf ?tgtParent .
							?tgtAspect rdfs:range ?tgtRangeDatatype .
							?tgtAspect skos:prefLabel ?tgtAspectPrefName .
							?tgtAspect skos:prefLabel ?tgtAspectAltName .
							?tgtAspect skos:definition ?tgtAspectDescription .
							
							?tgtAspect skos:note ?tgtAspectNote .
							?tgtAspect skos:notation ?tgtAspectCode .
							?tgtAspect nen2660:abbreviation ?tgtAspectAbbreviation .
							
							?tgtAspect ?tgtAnnotationProperty ?tgtAnnotationValue .
							?tgtAnnotationProperty a owl:AnnotationProperty .
							?tgtAnnotationProperty skos:prefLabel ?tgtAnnotationName .
							?tgtAnnotationProperty rdfs:range xsd:string .

							?tgtAspectWithValue sh:property ?bnode1 .
							?tgtAspectWithValue a sh:NodeShape .
							?tgtAspectWithValue sh:targetClass ?tgtObject .

							?tgtShape sh:property ?bnode1 .
							?bnode1 sh:path ?tgtAspect .
							?bnode1 ?ShaclValueType ?tgtAspectDatatype . 

							# This is either sh:datatype ?tgtAspectDatatype or sh:class ?tgtAspectDatatype, depending on what is correct. ^^ 
							?bnode1 sh:class ?tgtAspectEnumeration .
							?bnode1 sh:hasValue ?tgtQualificationUri .
							?bnode1 sh:minCount ?tgtMinCardinality .
							?bnode1 sh:maxCount ?tgtMaxCardinality .
							?bnode1 sh:node ?tgtQuantityValueNode .

							
							?tgtQuantityValueNode a sh:NodeShape .
							?tgtQuantityValueNode sh:property ?bnode3 .
							?bnode3 sh:path ?tgtUnitRelation .
							?bnode3 sh:hasValue ?tgtUnit .
							?bnode3 sh:minCount 1 . 
							?bnode3 sh:maxCount 1 . # Een gekoppelde waarde mag hooguit 1 unit hebben. (Moet het minstens 1 zijn?)
							?tgtQuantityValueNode sh:property ?bnode4 .
							?bnode4 sh:path rdf:value . 
							?bnode4 sh:minCount 1 . # Een gekoppelde Quantification moet 1 en hooguit 1 getal hebben. 
							?bnode4 sh:maxCount 1 . 
							?bnode4 sh:datatype ?tgtDatatype .
							?bnode4 sh:hasValue ?tgtQuantificationValue .
							?tgtObject rdfs:subClassOf ?bnode2 .
							?bnode2 a owl:Restriction .
							?bnode2 owl:minCardinality ?tgtMinCardinality .
							?bnode2 owl:onProperty ?tgtAspect .
							?bnode2 owl:onClass ?tgtAspectEnumeration .
							?bnode2 owl:hasValue ?tgtQualificationUri .
							?tgtQualificationUri skos:prefLabel ?tgtQualificationName .
							# ?tgtQualificationUri skos:prefLabel ?tgtENQualificationName .
							?bnode2 owl:hasValue ?tgtQuantificationValue .
						}
						WHERE {
							BIND (BNODE() AS ?bnode1) .
							BIND (BNODE() AS ?bnode2) .
							
							?hasAspect otl:rel-Relation-toRole ?this .
							?hasAspect otl:rel-Relation-to ?aspect .
							?hasAspect otl:rel-Relation-from ?object .
							?aspect a otl:Aspect .
							# Check if the object has a defined shape, otherwise create a shape
							{
								?hasAspect otl:rel-Relation-from ?object .
								?object otl:rel-Conceptual-hasShape ?shape .
								BIND (URI(STR(?shape)) AS ?tgtShape) .
							}
							UNION
							{
								?hasAspect otl:rel-Relation-toRole ?this .
								?hasAspect otl:rel-Relation-from ?object .
								FILTER NOT EXISTS {
									?object otl:rel-Conceptual-hasShape ?shape .
								} .
								BIND (ex:createURI(CONCAT(ex:localname(?object), "-Shape")) AS ?tgtAspectWithValue) .
							} .
							# Check if the aspect has a parent and whether it is an internal or external link 
							OPTIONAL {
								?aspect otl:rel-Conceptual-isSpecializationOf ?parentAspect .
								OPTIONAL {
									?parentAspect shapes:sequence/rdf:_1 ?parentName .
									BIND (URI(STR(?parentAspect)) AS ?newParentAspectURI) .
								} .
								BIND (COALESCE(?newParentAspectURI, ?parentAspect) AS ?tgtParent) .
							} .
							# Check if the aspect is internal or external
							{
								?hasAspect otl:rel-Relation-toRole ?this .
								?hasAspect otl:rel-Relation-to ?aspect .
								?aspect a otl:Aspect .
								BIND (URI(STR(?aspect)) AS ?tgtAspect) .
							}
							UNION
							{
								?hasAspect otl:rel-Relation-toRole ?this .
								?hasAspect otl:rel-Relation-to ?aspect .
								FILTER NOT EXISTS {
									?aspect a otl:Aspect .
								} .
								BIND (?aspect AS ?tgtAspect) .
							} .
							BIND (URI(STR(?object)) AS ?tgtObject) .
							
							# Get all the descriptive information of the aspect
							?aspect shapes:sequence/rdf:_1 ?tgtAspectPrefName .
							OPTIONAL {
								?aspect otl:attr-Conceptual-name ?tgtAspectAltName .
								?aspect shapes:sequence/rdf:_1 ?tgtAspectPrefName .
								FILTER (?tgtAspectAltName != ?tgtAspectPrefName) .
							} .
							OPTIONAL {
								?aspect otl:attr-Conceptual-description ?tgtAspectDescription .
							} .
							OPTIONAL {
								?this otl:attr-Conceptual-note ?tgtAspectNote .
							} .
							OPTIONAL {
								?this otl:attr-Conceptual-code ?tgtAspectCode .
							} .
							OPTIONAL {
								?this otl:attr-Conceptual-abbreviation ?tgtAspectAbbreviation .
							} .
							OPTIONAL {
								?aspect otl:rel-Conceptual-isDescribedIn ?informationField .
								?informationField otl:attr-InformationField-value ?tgtAnnotationValue .
								?informationField otl:rel-InformationField-isClassifiedAs ?informationType .
								?informationType otl:attr-Conceptual-name ?tgtAnnotationName .
								BIND (ex:createURI(MD5(?tgtAnnotationName)) AS ?tgtAnnotationProperty) .
							} .
							OPTIONAL {
								?this otl:rel-RoleOfAspect-PossessedAspect-hasShapeAttribute ?attribute .
								?attribute bm:attr-Component-maxCardinality ?maxCardinality .
								?attribute bm:attr-Component-minCardinality ?minCardinality .
								BIND (STRDT(str(?minCardinality), xsd:integer) AS ?tgtMinCardinality) .
								BIND (STRDT(str(?maxCardinality), xsd:integer) AS ?tgtMaxCardinality) .
							} .
							# Convert aspects that expect a qualification value
							{
								?this otl:rel-RoleOfAspect-PossessedAspect-hasShapeAttribute ?attribute .
								?attribute bm:attr-Attribute-datatype ?tgtDatatype .
								FILTER NOT EXISTS {
									?this otl:rel-RoleOfAspect-PossessedAspect-isQualifiedAsOneOf ?aspectEnumeration .
								} .
								?this otl:rel-RoleOfAspect-PossessedAspect-isQualifiedAs-Qualification ?emptyQualification .
								?emptyQualification otl:attr-Conceptual-name ?EmptyQualificationName .
								FILTER (?EmptyQualificationName = "") .
								BIND (sh:datatype AS ?ShaclValueType ) .
								BIND (?tgtDatatype AS ?tgtAspectDatatype) .
								BIND (rdfs:Resource AS ?tgtRangeDatatype) .
								BIND (owl:ObjectProperty AS ?tgtPropertyType) .
							}
							UNION
							# Convert aspects that have a qualification value filled
							{
								?this otl:rel-RoleOfAspect-PossessedAspect-isQualifiedAs-Qualification ?qualification .
								FILTER NOT EXISTS {
									?this otl:rel-RoleOfAspect-PossessedAspect-hasShapeAttribute ?attribute .
								} .
								?qualification otl:attr-Conceptual-name ?tgtQualificationName .
								FILTER (?tgtQualificationName != "") .
								# BIND(IF(CONTAINS(str(?tgtQualificationName), ","), STRBEFORE(?tgtQualificationName, ","), ?tgtQualificationName) AS ?tgtNLQualificationName) .
  								# BIND(IF(CONTAINS(str(?tgtQualificationName), ","), STRAFTER(?tgtQualificationName, ","), ?undefined) AS ?tgtENQualificationName) .

								BIND (URI(STR(?qualification)) AS ?tgtQualificationUri) .
								BIND (owl:ObjectProperty AS ?tgtPropertyType) .
							}
							UNION
							# Convert aspects with a qualification group
							{
								?this otl:rel-RoleOfAspect-PossessedAspect-isQualifiedAsOneOf ?aspectEnumeration .
								?this otl:rel-RoleOfAspect-PossessedAspect-isQualifiedAs-Qualification ?emptyQualification .
								?emptyQualification otl:attr-Conceptual-name ?EmptyQualificationName .
								FILTER (?EmptyQualificationName = "") .
								BIND (URI(STR(?aspectEnumeration)) AS ?tgtAspectEnumeration) .
								BIND (owl:ObjectProperty AS ?tgtPropertyType) .
								BIND (rdfs:Resource AS ?tgtRangeDatatype) .
							}
							UNION
							# Aspects with a quantification
							{
								# Aspects with a filled quantification value
								?this otl:rel-RoleOfAspect-PossessedAspect-isQualifiedAs-Quantification ?quantification .
								{
									?quantification otl:attr-Quantification-value ?tgtQuantificationValue .
								}
								UNION
								# Aspects that expect a quantification value
								{
									?this otl:rel-RoleOfAspect-PossessedAspect-hasShapeAttribute ?attribute .
									?this otl:rel-RoleOfAspect-PossessedAspect-isQualifiedAs-Quantification ?quantification .
									FILTER NOT EXISTS {
										?quantification otl:attr-Quantification-value ?quantificationValue .
									} .
									?attribute bm:attr-Attribute-datatype ?tgtDatatype .
								} .
								# Converting unit of measure
								# Always use nen2660:hasUnit (See https://confluence.semmtech.com/display/CON/NEN+2660+Stylesheet+%7C+Design+choices)
								?quantification otl:rel-Quantification-isQuantifiedOnScale ?unitOfMeasure .
								OPTIONAL { 
									?unitOfMeasure otl:rel-Conceptual-hasExternalLink ?externalLink1 .
									?externalLink1 otl:attr-ExternalLink-relation "isSameAs" .
									?externalLink1 otl:attr-ExternalLink-uri ?externalLinkUnitUri .
									FILTER regex(str(?externalLinkUnitUri), "http://qudt.org/vocab/unit/", "i") .
								}
								BIND (URI(STR(?unitOfMeasure)) AS ?implicitUnit) .
								BIND (COALESCE(URI(STR(?externalLinkUnitUri)), ?implicitUnit) AS ?tgtUnit) .
								BIND (URI(STR(?this)) AS ?tgtQuantityValueNode) .
								BIND (nen2660:hasUnit AS ?tgtUnitRelation) .
								
								BIND (BNODE() AS ?bnode3) .
								BIND (BNODE() AS ?bnode4) .
								BIND (owl:ObjectProperty AS ?tgtPropertyType) .
								BIND (sh:class AS ?ShaclValueType ) .
								BIND (nen2660:QuantityValue AS ?tgtRangeDatatype) .
								BIND (nen2660:QuantityValue AS ?tgtAspectDatatype) .
							} .
						} 
					""" ;
            sh:deactivated false ;
            sh:prefixes ex:,
                bm:,
                otl:,
                shapes:,
                rdf:,
                rdfs:,
                xsd:,
                owl:,
                skos:,
                sh:,
                schema:,
                nen2660: ] ;
    sh:targetClass otl:RoleOfAspect-PossessedAspect .

ex:ConvertAspectsWithoutRole a sh:NodeShape ;
    sh:rule [ a sh:SPARQLRule ;
            sh:construct """	
			CONSTRUCT {
				?tgtAspect a rdf:Property .
				?tgtAspect rdfs:subPropertyOf ?tgtParent .
				?tgtAspect skos:prefLabel ?tgtAspectPrefName .
				?tgtAspect skos:prefLaebl ?tgtAspectAltName .
				?tgtAspect skos:definition ?tgtAttributeDescription .
				?tgtAspect skos:note ?tgtAspectNote .
				?tgtAspect skos:notation ?tgtAspectCode .
				?tgtAspect nen2660:abbreviation ?tgtAspectAbbreviation .
				?tgtAspect rdfs:range ?tgtRangeDatatype .
				?tgtAspect ?tgtAnnotationProperty ?tgtAnnotationValue .
				?tgtAnnotationProperty a owl:AnnotationProperty .
				?tgtAnnotationProperty skos:prefLabel ?tgtAnnotationName .
				?tgtAnnotationProperty rdfs:range xsd:string .
			}
			WHERE {
				FILTER NOT EXISTS {
					?hasAspect otl:rel-Relation-to ?this .
				} .
				?this shapes:sequence/rdf:_1 ?tgtAspectPrefName .
				OPTIONAL {
					?this otl:attr-Conceptual-name ?tgtAspectAltName .
					?this shapes:sequence/rdf:_1 ?tgtAspectPrefName .
					FILTER (?tgtAspectAltName != ?tgtAspectPrefName) .
				} .
				# Check if the aspect has a parent and whether it is an internal or external link
				OPTIONAL {
					?this otl:rel-Conceptual-isSpecializationOf ?parentAspect .
					OPTIONAL {
						?parentAspect shapes:sequence/rdf:_1 ?parentName .
						BIND (URI(STR(?parentAspect)) AS ?newParentAspectURI) .
					} .
					BIND (COALESCE(?newParentAspectURI, ?parentAspect) AS ?tgtParent) .
				} .
				OPTIONAL {
					?this otl:attr-Conceptual-description ?tgtAspectDescription .
				} .
				OPTIONAL {
					?this otl:attr-Aspect-datatype ?tgtRangeDatatype
				} .
				OPTIONAL {
					?this otl:attr-Conceptual-note ?tgtAspectNote .
				} .
				OPTIONAL {
					?this otl:attr-Conceptual-code ?tgtAspectCode .
				} .
				OPTIONAL {
					?this otl:attr-Conceptual-abbreviation ?tgtAspectAbbreviation .
				} .

				# Get the information attribute
				OPTIONAL {
					?this otl:rel-Conceptual-isDescribedIn ?informationField .
					?informationField otl:attr-InformationField-value ?tgtAnnotationValue .
					?informationField otl:rel-InformationField-isClassifiedAs ?informationType .
					?informationType otl:attr-Conceptual-name ?tgtAnnotationName .
					BIND (CONCAT(?tgtAnnotationName, ": ", ?tgtAnnotationValue) AS ?tgtConceptualInformation) .
					FILTER (STRLEN(str(?tgtAnnotationValue)) > 0) .
					BIND (ex:createURI(MD5(?tgtAnnotationName)) AS ?tgtAnnotationProperty) .
				} .
				BIND (URI(STR(?this)) AS ?tgtAspect) .
			}
			""" ;
            sh:deactivated false ;
            sh:prefixes ex:,
                bm:,
                otl:,
                shapes:,
                rdf:,
                rdfs:,
                xsd:,
                owl:,
                skos:,
                sh:,
                schema:,
                nen2660: ] ;
    sh:targetClass otl:Aspect .

ex:ConvertFunctionalSpace a sh:NodeShape ;
    sh:rule [ a sh:SPARQLRule ;
            sh:construct """	
			CONSTRUCT {
				?tgtThis a geo:Feature .
			}
			WHERE {
				?tgtThis a otl:FunctionalSpace .
			}
			""" ;
            sh:deactivated false ;
            sh:prefixes ex:,
				sh:,
                otl:,
                geo: ] ;
    sh:targetClass otl:FunctionalSpace .



ex:ConvertConceptuals a sh:NodeShape ;
    sh:rule [ a sh:SPARQLRule ;
            sh:construct """	
			CONSTRUCT {
			    ?tgtThis a owl:Class .
			    ?tgtThis rdfs:subClassOf ?tgtParentConcept .
			    ?tgtThis skos:prefLabel ?tgtConceptualPrefName .
			    ?tgtThis skos:prefLabel ?tgtConceptualAltName .
			    ?tgtThis skos:definition ?tgtConceptualDescription .
			    ?tgtThis skos:note ?tgtConceptualNote .
			    ?tgtThis skos:notation ?tgtConceptualCode .
			    ?tgtThis nen2660:abbreviation ?tgtConceptualAbbreviation .
				?tgtThis skos:notation ?rvvCodeValue .
			    ?tgtThis ?tgtAnnotationProperty ?tgtAnnotationValue .
			    ?tgtAnnotationProperty a owl:AnnotationProperty .
			    ?tgtAnnotationProperty skos:prefLabel ?tgtAnnotationNLname, ?tgtAnnotationENname .
			    ?tgtAnnotationProperty rdfs:range xsd:string .
				?tgtThis rdfs:seeAlso ?tgtExternalSourceLink .
				?tgtExternalSourceLink dct:license ?license .
				?tgtThis nen2660:isDescribedBy ?tgtRelatedDocument .
			}
			WHERE {
			# Only certain subclasses of otl:Conceptual should be converted into classes (Qualifications for example should not be converted into instances of owl:Class)
				?this a ?conceptual .
    			FILTER (?conceptual IN (otl:PhysicalObject, otl:GeometricalSpace, otl:Activity, otl:Function, otl:Document, otl:FunctionalSpace, otl:Objective, otl:Agent, otl:Event, otl:State, otl:Risk, otl:TimePeriod, otl:Matter)) .
			# If the concept is a specialization of another concept in the OTL, it should be modeled by a rdfs:subClassOf relation between the two concepts
				OPTIONAL {
			        ?this otl:rel-Conceptual-isSpecializationOf ?parentConceptual .
			        OPTIONAL {
			            ?parentConceptual shapes:sequence/rdf:_1 ?parentName .
			            BIND (URI(STR(?parentConceptual)) AS ?newParentConceptualURI) .
			        } .
			    } .
    			BIND (COALESCE(?newParentConceptualURI, ?parentConceptual) AS ?newParentConceptual) .
			# All concepts should be placed under a root concept. These root concepts are only created if it will contain at least one member
			# The top concepts of the OTL are placed under a root concept, all other concepts are placed under their parent
				OPTIONAL {
					?conceptual rdfs:seeAlso ?ntaTopConceptual .
				} .	
				OPTIONAL {
					?conceptual skos:altLabel ?tgtTopConceptualLabel .
					BIND (ex:createURI(?tgtTopConceptualLabel) AS ?lacesTopConceptual) .
				} .
				BIND (COALESCE(?ntaTopConceptual, ?lacesTopConceptual) AS ?tgtTopConceptual) .
				BIND (COALESCE(?newParentConceptual, ?tgtTopConceptual) AS ?tgtParentConcept) .
			
			# This section finds any names, the preferred name, descriptions, notes, codes and abbreviations of the concept (if applicable).
				?this shapes:sequence/rdf:_1 ?tgtConceptualPrefName .
				OPTIONAL {
					?this otl:attr-Conceptual-name ?tgtConceptualAltName .
					?this shapes:sequence/rdf:_1 ?tgtConceptualPrefName .
					FILTER (?tgtConceptualAltName != ?tgtConceptualPrefName) .
				} .
				OPTIONAL {
					?this otl:attr-Conceptual-description ?tgtConceptualDescription .
				} .
				OPTIONAL {
					?this otl:attr-Conceptual-note ?tgtConceptualNote .
				} .
				OPTIONAL {
					?this otl:attr-Conceptual-code ?tgtConceptualCode .
				} .
				OPTIONAL {
					?this otl:attr-Conceptual-abbreviation ?tgtConceptualAbbreviation .
				} .
			#This part handles the image links.
				OPTIONAL {
					?this otl:describes ?tgtExternalSourceLink .
				}
				OPTIONAL {
					?this otl:describes ?tgtExternalSourceLink .
					FILTER(CONTAINS(str(?tgtExternalSourceLink), "https://github.com/ndwnu/qgis-verkeersborden-style/blob/main/svg_verkeersborden/"))
					BIND (<https://opensource.org/licenses/MIT> AS ?license) .
				}
			# This section finds any extra attributes of a concept that have been stored using the InformationField and InformationType classes. Each attribute is converted to one value by concatenating its InformationType and InformationField value.
				OPTIONAL {
					?this otl:rel-Conceptual-isDescribedIn ?informationField .
					?informationField otl:attr-InformationField-value ?tgtAnnotationValue .
					?informationField otl:rel-InformationField-isClassifiedAs ?informationType .
					?informationType otl:attr-Conceptual-name ?tgtAnnotationName .
					
					BIND (IF (CONTAINS(str(?tgtAnnotationName), ","), STRLANG(STRBEFORE(?tgtAnnotationName, ","), "nl"), ?tgtAnnotationName) AS ?tgtAnnotationNLname) .
					BIND (IF (CONTAINS(str(?tgtAnnotationName), ","), STRLANG(STRAFTER(?tgtAnnotationName, ","), "en"), ?undefined) AS ?tgtAnnotationENname) .

					BIND(IF(str(?tgtAnnotationName) = "rvvCode", ?tgtAnnotationValue, ?undefined) AS ?rvvCodeValue) .
					BIND (CONCAT(?tgtAnnotationName, ": ", ?tgtAnnotationValue) AS ?tgtConceptualInformation) .
					FILTER (STRLEN(str(?tgtAnnotationValue)) > 0) .
					BIND (IF (str(?tgtAnnotationName) != "rvvCode", ex:createURI(MD5(?tgtAnnotationName)), ?undefined) AS ?tgtAnnotationProperty) .					
				} .
				
			# This part is to find the otl:Document-isDescribedIn-Document relation
				OPTIONAL {
					?relation a otl:Document-isDescribedIn-Document .
					?relation otl:rel-Relation-from ?this .
					?relation otl:rel-Relation-to ?tgtRelatedDocument .
				}
				BIND (URI(STR(?this)) AS ?tgtThis) .
			}
			""" ;
            sh:deactivated false ;
            sh:prefixes ex:,
                bm:,
                otl:,
                shapes:,
                rdf:,
                rdfs:,
                xsd:,
                owl:,
                skos:,
                sh:,
                schema:,
				dct:,
                nen2660: ] ;
    sh:targetClass otl:Conceptual .

ex:ConvertExternalSource a sh:NodeShape ;
    sh:rule [ a sh:SPARQLRule ;
            sh:construct """	
			CONSTRUCT {
				?childConceptual rdfs:subClassOf ?tgtThis .
				?tgtThis owl:equivalentClass ?tgtSameAsExternalURI .
				?tgtThis skos:related ?tgtRelatedToExternalURI .
				?tgtThis ?shallBeCompliantWith ?tgtIsCompliantWithExternalURI .
			}
			WHERE {
				?this a ?conceptual .
				OPTIONAL {
					?childConceptual otl:rel-Conceptual-isSpecializationOf ?this .
					FILTER NOT EXISTS {
						?childConceptual otl:attr-Conceptual-name ?childName .
					} .
				} .
				OPTIONAL {
					?this otl:rel-Conceptual-hasExternalLink ?1externalRelation .
					?1externalRelation a otl:ExternalLink .
					?1externalRelation otl:attr-ExternalLink-relation "isSameAs" .
					?1externalRelation otl:attr-ExternalLink-uri ?sameAsExternalURI .
					FILTER (!regex(str(?sameAsExternalURI), "http://qudt.org/vocab/unit/", "i")) .
					BIND (URI(str(?sameAsExternalURI)) AS ?tgtSameAsExternalURI) .
				} .
				OPTIONAL {
					?this otl:rel-Conceptual-hasExternalLink ?2externalRelation .
					?2externalRelation a otl:ExternalLink .
					?2externalRelation otl:attr-ExternalLink-relation "isRelatedTo" .
					?2externalRelation otl:attr-ExternalLink-uri ?relatedToExternalURI .
					BIND (URI(str(?relatedToExternalURI)) AS ?tgtRelatedToExternalURI) .
				} .
				OPTIONAL {
					?this otl:rel-Conceptual-hasExternalLink ?3externalRelation .
					?3externalRelation a otl:ExternalLink .
					?3externalRelation otl:attr-ExternalLink-relation "isCompliantWith" .
					?3externalRelation otl:attr-ExternalLink-uri ?isCompliantWithExternalURI .
					BIND (URI(str(?isCompliantWithExternalURI)) AS ?tgtIsCompliantWithExternalURI) .
					BIND (ex:createURI("shallBeCompliantWith") AS ?shallBeCompliantWith) .
				} .
				BIND (URI(STR(?this)) AS ?tgtThis) .
			}
			""" ;
            sh:deactivated false ;
            sh:prefixes ex:,
                bm:,
                otl:,
                shapes:,
                rdf:,
                rdfs:,
                xsd:,
                owl:,
                skos:,
                sh:,
                schema:,
                nen2660: ] ;
    sh:targetClass otl:Conceptual .

ex:ConvertExternalSourceAspect a sh:NodeShape ;
    sh:rule [ a sh:SPARQLRule ;
            sh:construct """	
			CONSTRUCT {
				?tgtAspect owl:equivalentProperty ?tgtSameAsExternalURI .
				?tgtAspect skos:related ?tgtRelatedToExternalURI .
			}
			WHERE {
				?aspect otl:rel-Conceptual-hasExternalLink ?this .
				?aspect a otl:Aspect .
				OPTIONAL {
					?aspect otl:rel-Conceptual-hasExternalLink ?1externalRelation .
					?1externalRelation a otl:ExternalLink .
					?1externalRelation otl:attr-ExternalLink-relation "isSameAs" .
					?1externalRelation otl:attr-ExternalLink-uri ?sameAsExternalURI .
					BIND (URI(str(?sameAsExternalURI)) AS ?tgtSameAsExternalURI) .
				} .
				OPTIONAL {
					?aspect otl:rel-Conceptual-hasExternalLink ?2externalRelation .
					?2externalRelation a otl:ExternalLink .
					?2externalRelation otl:attr-ExternalLink-relation "isRelatedTo" .
					?2externalRelation otl:attr-ExternalLink-uri ?relatedToExternalURI .
					BIND (URI(str(?relatedToExternalURI)) AS ?tgtRelatedToExternalURI) .
				} .
				BIND (URI(STR(?aspect)) AS ?tgtAspect) .
			}
			""" ;
            sh:deactivated false ;
            sh:prefixes ex:,
                bm:,
                otl:,
                shapes:,
                rdf:,
                rdfs:,
                xsd:,
                owl:,
                skos:,
                sh:,
                schema:,
                nen2660: ] ;
    sh:targetClass otl:ExternalLink .

ex:ConvertGroupForQualifications a sh:NodeShape ;
    sh:rule [ a sh:SPARQLRule ;
            sh:construct """	
			CONSTRUCT {
				?tgtList a rdf:List .
				?tgtList rdf:first ?tgtElementUri .
				?tgtElementUri a ?tgtThis .
				?tgtElementUri skos:prefLabel ?tgtNLname .
				?tgtElementUri skos:prefLabel ?tgtENname .
				?tgtElementUri skos:definition ?nlDescription .
				?tgtElementUri skos:definition ?enDescription .
				?tgtElementUri rdfs:seeAlso ?link .
				?link skos:prefLabel ?linkName .
				?tgtList rdf:rest ?tgtRestList .
				?tgtThis rdfs:subClassOf nen2660:EnumerationType .
				?tgtThis a owl:Class .
				?tgtThis a sh:NodeShape .
				?tgtThis skos:prefLabel ?tgtEnumerationNLname .
				?tgtThis skos:prefLabel ?tgtEnumerationENname .
				?tgtThis skos:definition ?enumnlDescription .
				?tgtThis skos:definiton ?enumenDescription .
				?tgtThis sh:in ?tgtListFirst .
				?tgtThis owl:oneOf ?tgtListFirst .
			}
			WHERE {
				?possessedAspect otl:rel-RoleOfAspect-PossessedAspect-isQualifiedAsOneOf ?this .
				?possessedAspect otl:rel-RoleOfAspect-PossessedAspect-isQualifiedAs-Qualification ?emptyQualification .
				?emptyQualification otl:attr-Conceptual-name "" .
				{
					SELECT ?this ?qualification ?tgtElementName ((COUNT(?predecessor)) AS ?elementIndex)
					WHERE {
						?this a otl:GroupForQualifications .
						?this otl:rel-Group-isCollectionFor ?qualification .
						OPTIONAL {
							?this otl:rel-Group-isCollectionFor ?predecessor .
							FILTER (str(?predecessor) < str(?qualification)) .
						} .
						?qualification otl:attr-Conceptual-name ?tgtElementName .
					}
					GROUP BY ?this ?qualification ?tgtElementName
				} .
				{
					SELECT ?this ?qualification ?tgtElementName ?tgtElementDescription ((COUNT(?successor)) AS ?isLastElement)
					WHERE {
						?this a otl:GroupForQualifications .
						?this otl:rel-Group-isCollectionFor ?qualification .
						OPTIONAL {
							?this otl:rel-Group-isCollectionFor ?successor .
							FILTER (str(?successor) > str(?qualification)) .
						} .
						?qualification otl:attr-Conceptual-name ?tgtElementName .
						OPTIONAL {
							?qualification otl:attr-Conceptual-description ?tgtElementDescription .
						} .
					}
					GROUP BY ?this ?qualification ?tgtElementName ?tgtElementDescription
				} .

				BIND(IF(CONTAINS(str(?tgtElementName), ","), STRLANG(STRBEFORE(?tgtElementName, ","), "nl"), STRLANG(?tgtElementName, "nl")) AS ?tgtNLname) .
  				BIND(IF(CONTAINS(str(?tgtElementName), ","), STRLANG(STRAFTER(?tgtElementName, ","), "en"), ?undefined) AS ?tgtENname) .
				# BIND(IF(REGEX(?tgtElementName, '^"([^"]*)",'), STRLANG(REPLACE(?tgtElementName, '^"([^"]*)",".*$', '$1'), "nl"), STRLANG(?tgtElementName, "nl")) AS ?tgtNLnameQuoted) .
				# BIND(IF(REGEX(?tgtElementName, '^"([^"]*)",'), STRLANG(REPLACE(?tgtElementName, '^".*","([^"]*)"$', '$1'), "en"), ?undefined) AS ?tgtENnameQuoted) .
				# BIND(COALESCE(?tgtNLnameQuoted, ?nlName) AS ?tgtNLname) .
				# BIND(COALESCE(?tgtENnameQuoted, ?enName) AS ?tgtENname) .

				BIND(IF(CONTAINS(str(?tgtElementDescription), "$"), STRBEFORE(?tgtElementDescription, "$"), ?tgtElementDescription) AS ?descriptions) .
  				BIND(IF(CONTAINS(str(?tgtElementDescription), "$"), STRAFTER(?tgtElementDescription, "$"), ?undefined) AS ?rest) .
				BIND(COALESCE(?descriptions, ?tgtElementDescription) AS ?tgtdescriptions)
  				BIND(IF(REGEX(?tgtdescriptions, '^"([^"]*)",'), STRLANG(REPLACE(?tgtdescriptions, '^"([^"]*)",".*$', '$1'), "nl"), STRLANG(?tgtdescriptions, "nl")) AS ?nlDescription) .
				BIND(IF(REGEX(?tgtdescriptions, '^"([^"]*)",'), STRLANG(REPLACE(?tgtdescriptions, '^".*","([^"]*)"$', '$1'), "en"), ?undefined) AS ?enDescription) .

				BIND(IF(CONTAINS(str(?rest), "]"), STRAFTER(STRBEFORE(?rest, "]"), "["), ?undefined) AS ?linkName) .
				BIND(IF(CONTAINS(str(?rest), "]"), STRAFTER(	STRBEFORE(STRAFTER(?rest, "]"), ")")	,"(") , ?undefined) AS ?strlink) .
				BIND(URI(?strlink) AS ?link) .

				# GroupForQualification
				?this otl:attr-Group-name ?EnumerationName .
				BIND(IF(CONTAINS(str(?EnumerationName), "$"), STRBEFORE(?EnumerationName, "$"), ?EnumerationName) AS ?tgtEnumNames) .
  				BIND(IF(CONTAINS(str(?EnumerationName), "$"), STRAFTER(?EnumerationName, "$"), ?undefined) AS ?tgtEnumDescriptions) .
				# BIND(COALESCE(?EnumNames, ?EnumerationName) AS ?tgtEnumNames)

				BIND(IF(CONTAINS(str(?tgtEnumNames), ","), STRLANG(STRBEFORE(?tgtEnumNames, ","), "nl"), STRLANG(?tgtEnumNames,"nl")) AS ?tgtEnumerationNLname) .
  				BIND(IF(CONTAINS(str(?tgtEnumNames), ","), STRLANG(STRAFTER(?tgtEnumNames, ","), "en"), ?undefined) AS ?tgtEnumerationENname) .
				BIND(IF(REGEX(?tgtEnumDescriptions, '^"([^"]*)",'), STRLANG(REPLACE(?tgtEnumDescriptions, '^"([^"]*)",".*$', '$1'), "nl"), STRLANG(?tgtEnumDescriptions, "nl")) AS ?enumnlDescription) .
				BIND(IF(REGEX(?tgtEnumDescriptions, '^"([^"]*)",'), STRLANG(REPLACE(?tgtEnumDescriptions, '^".*","([^"]*)"$', '$1'), "en"), ?undefined) AS ?enumenDescription) .

				BIND (URI(STR(?this)) AS ?tgtThis) .
				BIND (URI(STR(?qualification)) AS ?tgtElementUri) .
				BIND (CONCAT(str(?tgtThis), "-list-") AS ?listBase) .
				BIND (IRI(CONCAT(?listBase, "0")) AS ?tgtListFirst) .
				BIND (IRI(CONCAT(?listBase, str(?elementIndex))) AS ?tgtList) .
				BIND (IF((?isLastElement = 0), rdf:nil, URI(CONCAT(?listBase, str((?elementIndex + 1))))) AS ?tgtRestList) .
			}
			""" ;
            sh:deactivated false ;
            sh:prefixes ex:,
                bm:,
                otl:,
                shapes:,
                rdf:,
                rdfs:,
                xsd:,
                owl:,
                skos:,
                sh:,
                schema:,
                nen2660: ] ;
    sh:targetClass otl:GroupForQualifications .

ex:ConvertGroups a sh:NodeShape ;
    sh:rule [ a sh:SPARQLRule ;
            sh:construct """	
			CONSTRUCT {
				?tgtThis a rdfs:Container .
				?tgtThis skos:prefLabel ?tgtNLGroupname .
				?tgtThis skos:prefLabel ?tgtENGroupname .
				?tgtThis rdfs:member ?tgtConceptual .
				?tgtThis rdfs:member ?tgtPartGroup .
			}
			WHERE {
			# otl:GroupForQualifications is a subclass of otl:Group. Its instances should not be used in this conversion
				FILTER NOT EXISTS {
					?this a otl:GroupForQualifications .
				} .
			# Find the conceptuals that are part of the group
				?this otl:rel-Group-isCollectionFor ?conceptual .
				BIND (URI(STR(?conceptual)) AS ?tgtConceptual) .
			# Find the group names if applicable
				OPTIONAL {
					?this otl:attr-Group-name ?tgtGroupName .
					BIND(IF(CONTAINS(str(?tgtGroupName), ","), STRBEFORE(?tgtGroupName, ","), ?tgtGroupName) AS ?tgtNLGroupname) .
  					BIND(IF(CONTAINS(str(?tgtGroupName), ","), STRAFTER(?tgtGroupName, ","), ?undefined) AS ?tgtENGroupname) .
				} .
			# Find groups that are part of this group, these will be added as group members, just like conceptuals
				OPTIONAL {
					?this otl:rel-Group-isWholeFor ?partGroup .
					BIND (URI(STR(?partGroup)) AS ?tgtPartGroup) .
				} .
				BIND (URI(STR(?this)) AS ?tgtThis) .
			}
			""" ;
            sh:deactivated false ;
            sh:prefixes ex:,
                bm:,
                otl:,
                shapes:,
                rdf:,
                rdfs:,
                xsd:,
                owl:,
                skos:,
                sh:,
                schema:,
                nen2660: ] ;
    sh:targetClass otl:Group .

ex:ConvertRelations a sh:NodeShape ;
    sh:rule [ a sh:SPARQLRule ;
            sh:construct """	
			CONSTRUCT {
				?tgtFrom rdfs:subClassOf ?bnode1 .
				?bnode1 a owl:Restriction .
				?bnode1 owl:onProperty ?tgtRelation .
				?bnode1 owl:onClass ?tgtTo .
				?bnode1 owl:minQualifiedCardinality ?tgtMinCardinality .
				?bnode1 owl:maxQualifiedCardinality ?tgtMaxCardinality .
				?tgtShapeFromLaces a sh:NodeShape .
				?tgtShapeFromLaces sh:targetClass ?tgtFrom .
				?tgtShapeFromLaces sh:property ?bnode2 .
				?bnode2 sh:qualifiedValueShape ?bnode3 .
				?bnode3 sh:class ?tgtTo .
				?bnode2 sh:path ?tgtRelation .
				?bnode2 sh:qualifiedMinCount ?tgtMinCardinality .
				?bnode2 sh:qualifiedMaxCount ?tgtMaxCardinality .
			}
			WHERE {
				BIND (BNODE() AS ?bnode1) .
				BIND (BNODE() AS ?bnode2) .
				BIND (BNODE() AS ?bnode3) .
				?this otl:rel-Relation-from ?from .
				?this otl:rel-Relation-to ?to .
				?this a ?lacesRelation .
				FILTER NOT EXISTS { 
					?lacesRelation rdfs:subClassOf otl:hasAspect .
				}
				FILTER NOT EXISTS { 
					?lacesRelation rdfs:subClassOf otl:isWholeFor .
				}
				OPTIONAL {
					?this otl:attr-Relation-minCardinality ?minCardinality .
				} .
				OPTIONAL {
					?this otl:attr-Relation-maxCardinality ?tgtMaxCardinality .
				} .
				OPTIONAL { 
					?lacesRelation rdfs:seeAlso ?bsRelation0 . 
				}
				OPTIONAL {
					?lacesRelation rdfs:subClassOf ?lacesTopRelation .
					FILTER(STRSTARTS(STR(?lacesTopRelation), "http://www.laces.tech/publication/")) .
					?lacesTopRelation rdfs:seeAlso ?bsRelation1 .
				} .
				OPTIONAL {
					?lacesRelation rdfs:subClassOf ?lacesTopRelation .
					FILTER(STRSTARTS(STR(?lacesTopRelation), "http://www.laces.tech/publication/")) .
					?lacesTopRelation skos:altLabel ?relationName .
					BIND (ex:createURI(?relationName) AS ?bsRelation2) .
				} .
				OPTIONAL {
					?from otl:rel-Conceptual-hasShape ?shapeFrom .
					BIND (?shapeFrom AS ?shapeFromReused) .
				} .
				BIND (COALESCE(?shapeFromReused, ex:createURI(CONCAT(ex:localname(?from), "-Shape"))) AS ?tmpShapeFrom) .
				OPTIONAL {
					?lacesRelation rdfs:subClassOf ?lacesTopRelation .
					FILTER(STRSTARTS(STR(?lacesTopRelation), "http://www.laces.tech/publication/")) .
					?lacesTopRelation owl:inverseOf ?inverseRelationStr .
					BIND (URI(?inverseRelationStr) AS ?inverseRelation) .
				} .
				OPTIONAL {
					?to otl:rel-Conceptual-hasShape ?shapeTo .
					BIND (?shapeTo AS ?shapeToReused) .
				} .
				BIND (COALESCE(?shapeToReused, ex:createURI(CONCAT(ex:localname(?to), "-Shape"))) AS ?tmpShapeTo) .
				
				BIND (IF(bound(?inverseRelation) && !bound(?bsRelation0), ?to, ?from) AS ?tgtFrom) .
				BIND (IF(bound(?inverseRelation) && !bound(?bsRelation0), ?from, ?to) AS ?tgtTo) .
				BIND (IF(bound(?inverseRelation) && !bound(?bsRelation0), ?tmpShapeTo,?tmpShapeFrom) AS ?tgtShapeFromLaces) .
				BIND (IF(bound(?minCardinality), ?minCardinality, IF(bound(?maxCardinality), ?null, "0"^^xsd:nonNegativeInteger)) AS ?tgtMinCardinality) .
				BIND (COALESCE(?bsRelation0, ?inverseRelation, ?bsRelation1, ?bsRelation2) AS ?tgtRelation) .
			}

			""" ;
            sh:deactivated false ;
            sh:prefixes ex:,
                bm:,
                otl:,
                shapes:,
                rdf:,
                rdfs:,
                xsd:,
                owl:,
                skos:,
                sh:,
                schema:,
                nen2660: ] ;
    sh:targetClass otl:Relation .

ex:ConvertShapes a sh:NodeShape ;
    sh:rule [ a sh:SPARQLRule ;
            sh:construct """	
			CONSTRUCT {
				?tgtThis a sh:NodeShape .
				?tgtThis sh:targetClass ?tgtShapeObject .
				?tgtThis skos:prefLabel ?tgtNLObjectName .
				?tgtThis skos:prefLabel ?tgtENObjectName .
				?tgtThis skos:definition ?tgtObjectDescription .
				?tgtThis skos:note ?tgtObjectNote .
			}
			WHERE {
				?shapeObject otl:rel-Conceptual-hasShape ?this .
				BIND (URI(STR(?shapeObject)) AS ?tgtShapeObject) .
				OPTIONAL {
					?this bm:attr-ShapeElement-name ?tgtObjectName .
					BIND(IF(CONTAINS(str(?tgtObjectName), ","), STRLANG(STRBEFORE(?tgtObjectName, ","), "nl"), STRLANG(?tgtObjectName, "nl")) AS ?tgtNLObjectName) .
  					BIND(IF(CONTAINS(str(?tgtObjectName), ","), STRLANG(STRAFTER(?tgtObjectName, ","), "en"), ?undefined) AS ?tgtENObjectName) .
				} .
				OPTIONAL {
					?this bm:attr-ShapeElement-description ?tgtObjectDescription .
				} .
				OPTIONAL {
					?this bm:attr-ShapeElement-note ?tgtObjectNote .
				} .
				BIND (URI(STR(?this)) AS ?tgtThis) .
			}
			""" ;
            sh:deactivated false ;
            sh:prefixes ex:,
                bm:,
                otl:,
                shapes:,
                rdf:,
                rdfs:,
                xsd:,
                owl:,
                skos:,
                sh:,
                schema:,
                nen2660: ] ;
    sh:targetClass bm:Shape .

ex:ConvertUnitOfMeasure a sh:NodeShape ;
    sh:rule [ a sh:SPARQLRule ;
            sh:construct """	
			CONSTRUCT {
				?tgtUnitOfMeasure a <http://qudt.org/schema/qudt/Unit>.
				?tgtUnitOfMeasure skos:prefLabel ?tgtNLUnitName .
				?tgtUnitOfMeasure skos:prefLabel ?tgtENUnitName .
				?tgtUnitOfMeasure ?tgtAnnotationProperty ?tgtAnnotationValue .
				?tgtAnnotationProperty a owl:AnnotationProperty .
				?tgtAnnotationProperty skos:prefLabel ?tgtNLAnnotationName .
				?tgtAnnotationProperty skos:prefLabel ?tgtENAnnotationName .
				?tgtAnnotationProperty rdfs:range xsd:string .
			}
			WHERE {
				?this shapes:sequence/rdf:_1 ?tgtUnitName .
				BIND(IF(CONTAINS(str(?tgtUnitName), ","), STRBEFORE(?tgtUnitName, ","), ?tgtUnitName) AS ?tgtNLUnitName) .
  				BIND(IF(CONTAINS(str(?tgtUnitName), ","), STRAFTER(?tgtUnitName, ","), ?undefined) AS ?tgtENUnitName) .
				FILTER NOT EXISTS {
					?this otl:rel-Conceptual-hasExternalLink ?externalLink .
					?externalLink otl:attr-ExternalLink-relation "isSameAs" .
					?externalLink otl:attr-ExternalLink-uri ?externalUnitUri .
					FILTER regex(str(?externalUnitUri), "http://qudt.org/vocab/unit/", "i") .
				} .
				OPTIONAL {
					?this otl:rel-Conceptual-isDescribedIn ?informationField .
					?informationField otl:attr-InformationField-value ?tgtAnnotationValue .
					?informationField otl:rel-InformationField-isClassifiedAs ?informationType .
					?informationType otl:attr-Conceptual-name ?tgtAnnotationName .
					FILTER (STRLEN(str(?tgtAnnotationValue)) > 0) .
					BIND(IF(CONTAINS(str(?tgtAnnotationName), ","), STRBEFORE(?tgtAnnotationName, ","), ?tgtAnnotationName) AS ?tgtNLAnnotationName) .
  					BIND(IF(CONTAINS(str(?tgtAnnotationName), ","), STRAFTER(?tgtAnnotationName, ","), ?undefined) AS ?tgtENAnnotationName) .
					BIND (ex:createURI(MD5(?tgtAnnotationName)) AS ?tgtAnnotationProperty) .
				} .
				
				BIND (URI(STR(?this)) AS ?tgtUnitOfMeasure) .
			}
			""" ;
            sh:deactivated false ;
            sh:prefixes ex:,
                bm:,
                otl:,
                shapes:,
                rdf:,
                rdfs:,
                xsd:,
                owl:,
                skos:,
                sh:,
                schema:,
                nen2660: ] ;
    sh:targetClass otl:UnitOfMeasure .

ex:ConvertWholeFor a sh:NodeShape ;
    sh:rule [ a sh:SPARQLRule ;
            sh:construct """	
			CONSTRUCT {
				?tgtShapeWhole sh:property ?bnode1 .
				?tgtShapeWhole a sh:NodeShape .
				?tgtShapeWhole sh:targetClass ?tgtObjectWhole .
				?bnode1 sh:path nen2660:hasPart .
				?bnode1 sh:qualifiedMinCount ?tgtMinCardinalityINT .
				?bnode1 sh:qualifiedMaxCount ?tgtPartMaxCardinalityINT .
				?bnode1 sh:qualifiedValueShape ?bnode2 .
				?bnode2 sh:class ?tgtObjectPart .
				?tgtObjectWhole rdfs:subClassOf ?bnode3 .
				?bnode3 a owl:Restriction .
				?bnode3 owl:onProperty nen2660:hasPart .
				?bnode3 owl:minQualifiedCardinality ?tgtMinCardinality .
				?bnode3 owl:maxQualifiedCardinality ?tgtPartMaxCardinality .
				?bnode3 owl:onClass ?tgtObjectPart .
			}
			WHERE {
				BIND (BNODE() AS ?bnode1) .
				BIND (BNODE() AS ?bnode2) .
				BIND (BNODE() AS ?bnode3) .
				?this a ?thisType .
				FILTER CONTAINS(str(?thisType), "isWholeFor") .
				?this otl:rel-Relation-from ?objectWhole .
				# Check if the ?objectWhole has a name (if not then this object is an external source and the URI should stay the same)
				OPTIONAL {
					?objectWhole shapes:sequence/rdf:_1 ?objectWholeName .
					BIND (URI(STR(?objectWhole)) AS ?objectWholeURI) .
				} .
				BIND (COALESCE(?objectWholeURI, ?objectWhole) AS ?tgtObjectWhole) .
				
				?this otl:rel-Relation-to ?objectPart .
				# Check if ?objectPart has a name (same reason ?objectWhole)
				OPTIONAL {
					?objectPart shapes:sequence/rdf:_1 ?objectPartName .
					BIND (URI(STR(?objectPart)) AS ?objectPartURI) .
				} .
				BIND (COALESCE(?objectPartURI, ?objectPart) AS ?tgtObjectPart) .
				# Check of the ?objectWhole has a shape, if yes, reuse. If not create shape
				OPTIONAL {
					?objectWhole otl:rel-Conceptual-hasShape ?shapeWhole .
					BIND (URI(STR(?shapeWhole)) AS ?tgtShapeWholeReused) .
				} .
				BIND (COALESCE(?tgtShapeWholeReused, ex:createURI(CONCAT(ex:localname(?objectWhole), "-Shape"))) AS ?tgtShapeWhole) .
				# Retrieve the minimum cardinality
				OPTIONAL {
					?this otl:attr-Relation-minCardinality ?partMinCardinality .
				} .
				# Find the maximum cardinality
				OPTIONAL {
					?this otl:attr-Relation-maxCardinality ?tgtPartMaxCardinality .
				} .
				BIND (IF((!bound(?partMinCardinality)), IF((!bound(?tgtPartMaxCardinality)), "0"^^xsd:nonNegativeInteger, ?undefined), ?partMinCardinality) AS ?tgtMinCardinality) .
				BIND (STRDT(str(?tgtMinCardinality), xsd:integer) AS ?tgtMinCardinalityINT) .
				BIND (STRDT(str(?tgtPartMaxCardinality), xsd:integer) AS ?tgtPartMaxCardinalityINT) .
			}
			""" ;
            sh:deactivated false ;
            sh:prefixes ex:,
                bm:,
                otl:,
                shapes:,
                rdf:,
                rdfs:,
                xsd:,
                owl:,
                skos:,
                sh:,
                schema:,
                nen2660: ] ;
    sh:targetClass otl:isWholeFor .

ex:CreateOntology a sh:NodeShape ;
    sh:rule [ a sh:SPARQLRule ;
            sh:construct """	
			CONSTRUCT {
			    ?tgtInferredOntology a owl:Ontology .
			    ?tgtInferredOntology owl:imports <https://w3id.org/nen2660/def#> .
			    ?tgtInferredOntology dct:date ?tgtVersionDate .
			    ?tgtInferredOntology skos:prefLabel ?tgtOntologyName .
			    ?tgtInferredOntology rdfs:comment ?tgtOntologyDescription .
			    ?tgtPhysicalObject a owl:Class .
			    ?tgtPhysicalObject skos:prefLabel "physical object"@en .
			    ?tgtPhysicalObject skos:prefLabel "fysiek object"@nl .
			    ?tgtActivity a owl:Class .
			    ?tgtActivity skos:prefLabel "activity"@en .
			    ?tgtActivity skos:prefLabel "activiteit"@nl .
			    ?tgtFunction a owl:Class .
			    ?tgtFunction skos:prefLabel "function"@en .
			    ?tgtFunction skos:prefLabel "functie"@nl .
			    ?tgtFunction rdfs:subClassOf ?tgtActivity .
			    ?tgtObjective a owl:Class .
			    ?tgtObjective skos:prefLabel "objective"@en .
			    ?tgtObjective skos:prefLabel "doel"@nl .
			    ?tgtObjective rdfs:subClassOf nen2660:State .
			    ?tgtRisk a owl:Class .
			    ?tgtRisk skos:prefLabel "risk"@en .
			    ?tgtRisk skos:prefLabel "risico"@nl .
			    ?tgtRisk rdfs:subClassOf ?tgtActivity .
			    ?tgtAgent a owl:Class .
			    ?tgtAgent skos:prefLabel "agent"@en .
			    ?tgtAgent skos:prefLabel "actor"@nl .
			    ?tgtAgent rdfs:subClassOf ?tgtPhysicalObject .
			    ?tgtSpatialRegion a owl:Class .
			    ?tgtSpatialRegion skos:prefLabel "Geometric entity"@en .
			    ?tgtSpatialRegion skos:prefLabel "geometrische entiteit"@nl .
			    ?tgtEvent a owl:Class .
			    ?tgtEvent skos:prefLabel "event"@en .
			    ?tgtEvent skos:prefLabel "gebeurtenis"@nl .
			    ?tgtInformationObject a owl:Class .
			    ?tgtInformationObject skos:prefLabel "information object"@en .
			    ?tgtInformationObject skos:prefLabel "informatieobject"@nl .
			    ?tgtDocument a owl:Class .
			    ?tgtDocument skos:prefLabel "document"@en .
			    ?tgtDocument skos:prefLabel "document"@nl .
			    ?tgtDocument rdfs:subClassOf ?tgtInformationObject .
			    ?tgtFile a owl:Class .
			    ?tgtFile skos:prefLabel "file"@en .
			    ?tgtFile skos:prefLabel "file"@nl .
			    ?tgtFile rdfs:subClassOf ?tgtInformationObject .
			    ?tgtEnumerationType a owl:Class .
			    ?tgtEnumerationType skos:prefLabel "enumeration type"@en .
			    ?tgtEnumerationType skos:prefLabel "enumeratietype"@nl .
			    ?tgtState a owl:Class .
			    ?tgtState skos:prefLabel "state"@en .
			    ?tgtState skos:prefLabel "toestand"@nl .
			    nen2660:hasPart a owl:ObjectProperty .
			    nen2660:hasPart skos:prefLabel "has part"@en .
			    nen2660:hasPart skos:prefLabel "heeft onderdeel"@nl .
				?tgtMatter a owl:Class .
			    ?tgtMatter skos:prefLabel "matter"@en .
			    ?tgtMatter skos:prefLabel "materie"@nl .
				?tgtFunctionalSpace a owl:Class . 
				?tgtFunctionalSpace skos:prefLabel "Spatial region"@en . 
				?tgtFunctionalSpace skos:prefLabel "Ruimtelijk gebied"@nl . 
			}
			WHERE {
			    ?this a owl:Ontology .
				FILTER (!STRSTARTS(str(?this), "http://hub.laces.tech/semmtech/schemas")) .
				#Filtering out contract manager and blueprint manager.
				FILTER (!STRSTARTS(str(?this), "http://models.laces.tech/")) .
				FILTER (!STRSTARTS(str(?this), "http://data.semmtech.com/sem/")) .
			    
				?this rdfs:label ?tgtOntologyName .
			    OPTIONAL { 
				?this dct:description ?tgtOntologyDescription .
			    ?this dct:date ?versionDate .
				BIND (REPLACE(?versionDate, "T[0-9]{2}:[0-9]{2}:[0-9]{2}.[0-9]{6}", "") AS ?tgtVersionDate) .
				}
			    BIND (ex:createURI("") AS ?tgtInferredOntology) .
			    BIND (ex:createURI("Function") AS ?tgtFunction) .
			    BIND (ex:createURI("Objective") AS ?tgtObjective) .
			    BIND (ex:createURI("Risk") AS ?tgtRisk) .
			    BIND (ex:createURI("Agent") AS ?tgtAgent) .
			    BIND (ex:createURI("Document") AS ?tgtDocument) .
			    BIND (ex:createURI("File") AS ?tgtFile) .
			    BIND (nen2660:GeometricEntity AS ?tgtSpatialRegion) .
			    BIND (nen2660:RealObject AS ?tgtPhysicalObject) .
			    BIND (nen2660:Activity AS ?tgtActivity) .
			    BIND (nen2660:Event AS ?tgtEvent) .
			    BIND (nen2660:InformationObject AS ?tgtInformationObject) .
			    BIND (nen2660:EnumerationType AS ?tgtEnumerationType) .
			    BIND (nen2660:State AS ?tgtState) .
				BIND (nen2660:Matter AS ?tgtMatter) .
				BIND (nen2660:SpatialRegion AS ?tgtFunctionalSpace ) . 
			}
			""" ;
            sh:deactivated false ;
            sh:prefixes ex:,
                dct:,
                bm:,
                otl:,
                shapes:,
                rdf:,
                rdfs:,
                xsd:,
                owl:,
                skos:,
                sh:,
                schema:,
                nen2660: ] ;
    sh:targetClass owl:Ontology .

ex:createURI a sh:SPARQLFunction ;
    sh:parameter [ sh:datatype xsd:string ;
            sh:description "The first operand" ;
            sh:path ex:op1 ] ;
    sh:prefixes ex:,
        dct:,
        rdfs:,
        owl: ;
    sh:returnType rdfs:Resource ;
    sh:select """
		SELECT ?uri
		WHERE {	
			?namespace a owl:Ontology .
			FILTER (!STRSTARTS(str(?namespace), "http://hub.laces.tech/semmtech/schemas")) . 
			?namespace rdfs:label ?ontologyName . # This one also does nothing, but can be left in. 
			?namespace <http://purl.org/dc/terms/description> ?description . 

			BIND (URI(CONCAT(STR(?namespace),  str($op1))) AS ?uri) .
		}
		LIMIT 1
		""" .

ex:localname a sh:SPARQLFunction ;
    sh:parameter [ sh:datatype xsd:string ;
            sh:description "The first operand" ;
            sh:path ex:op1 ] ;
    sh:prefixes ex: ;
    sh:returnType rdfs:Resource ;
    sh:select """
		SELECT ?localname
		WHERE {
			BIND (IF(CONTAINS(str($op1), "#"), STRAFTER(str($op1), "#"), REPLACE(str($op1), "(.*)[//]", "")) AS ?localname) .
		}
		""" .

kos: sh:declare [ sh:namespace "http://www.laces.tech/publication/ns/semmtech/live/laces/schema/kos/"^^xsd:anyURI ;
            sh:prefix "kos" ] .

kos:IndividualActivity rdfs:seeAlso nen2660:Activity .

kos:IndividualAgent skos:altLabel "Agent" .

kos:IndividualDocument skos:altLabel "Document" .

kos:IndividualFunction skos:altLabel "Function" .

kos:IndividualObject rdfs:seeAlso nen2660:RealObject .

kos:IndividualObjective skos:altLabel "Objective" .

kos:IndividualSpace skos:altLabel "Space" .

otl:Activity rdfs:seeAlso nen2660:Activity .

otl:Activity-isLocatedAt-GeometricalSpace rdfs:seeAlso nen2660:hasInterior .

otl:Agent skos:altLabel "Agent" .

otl:Document skos:altLabel "Document" .

otl:Event rdfs:seeAlso nen2660:Event .

otl:Function skos:altLabel "Function" .

otl:FunctionalSpace rdfs:seeAlso nen2660:SpatialRegion .

otl:FunctionalSpace-isLocatedAt-GeometricalSpace rdfs:seeAlso nen2660:hasInterior .

otl:GeometricalSpace rdfs:seeAlso nen2660:GeometricEntity .

otl:Matter rdfs:seeAlso nen2660:Matter .

otl:Objective skos:altLabel "Objective" .

otl:PhysicalObject rdfs:seeAlso nen2660:RealObject .

otl:PhysicalObject-isLocatedAt-GeometricalSpace rdfs:seeAlso nen2660:hasInterior .

otl:Risk skos:altLabel "Risk" .

otl:State rdfs:seeAlso nen2660:State .

otl:TimePeriod rdfs:seeAlso nen2660:TemporalEntity .

otl:consistsOf rdfs:seeAlso nen2660:consistsOf .

otl:describes owl:inverseOf nen2660:isDescribedBy .

otl:hasAsSubject skos:altLabel "hasAsSubject" .

otl:hasState rdfs:seeAlso nen2660:hasState .

otl:isAccountableFor skos:altLabel "isAccountableFor" .

otl:isApproverOf skos:altLabel "isApproverOf" .

otl:isAuthorOf skos:altLabel "isAuthorOf" .

otl:isConnectedTo rdfs:seeAlso nen2660:isConnectedTo .

otl:isConsultedFor skos:altLabel "isConsultedFor" .

otl:isFulfillerOf skos:altLabel "isFulfillerOf" .

otl:isInformedFor skos:altLabel "isInformedFor" .

otl:isInputOf skos:altLabel "isInputOf" .

otl:isLocatedAt owl:inverseOf nen2660:contains .

otl:isOutputOf skos:altLabel "isOutputOf" .

otl:isPerformerOf rdfs:seeAlso nen2660:executes ;
    skos:altLabel "isPerformerOf" .

otl:isReleaserOf skos:altLabel "isReleaserOf" .

otl:isResponsibleFor skos:altLabel "isResponsibleFor" .

otl:isSupportiveFor skos:altLabel "isSupportiveFor" .

otl:transforms rdfs:seeAlso nen2660:transforms ;
    skos:altLabel "transforms" .

geo: sh:declare [sh:namespace "http://www.opengis.net/ont/geosparql#"^^xsd:anyURI ;
			sh:prefix "geo"] .

specifications: sh:declare [ sh:namespace "http://www.laces.tech/publication/ns/semmtech/live/laces/schema/specifications/"^^xsd:anyURI ;
            sh:prefix "specifications" ] .

bs: sh:declare [ sh:namespace "https://w3id.org/def/basicsemantics-owl#"^^xsd:anyURI ;
            sh:prefix "bs" ] .

dct: sh:declare [ sh:namespace "http://purl.org/dc/terms/"^^xsd:anyURI ;
            sh:prefix "dct" ] .

bm: sh:declare [ sh:namespace "http://www.laces.tech/publication/ns/semmtech/live/laces/schema/blueprint-manager/"^^xsd:anyURI ;
            sh:prefix "bm" ] .

otl: sh:declare [ sh:namespace "http://www.laces.tech/publication/ns/semmtech/live/laces/schema/otl-manager/"^^xsd:anyURI ;
            sh:prefix "otl" ] .

shapes: sh:declare [ sh:namespace "http://www.laces.tech/publication/ns/semmtech/live/laces/schema/shapes/"^^xsd:anyURI ;
            sh:prefix "shapes" ] .

rdf: sh:declare [ sh:namespace "http://www.w3.org/1999/02/22-rdf-syntax-ns#"^^xsd:anyURI ;
            sh:prefix "rdf" ] .

xsd: sh:declare [ sh:namespace "http://www.w3.org/2001/XMLSchema#"^^xsd:anyURI ;
            sh:prefix "xsd" ] .

skos: sh:declare [ sh:namespace "http://www.w3.org/2004/02/skos/core#"^^xsd:anyURI ;
            sh:prefix "skos" ] .

sh: sh:declare [ sh:namespace "http://www.w3.org/ns/shacl#"^^xsd:anyURI ;
            sh:prefix "sh" ] .

schema: sh:declare [ sh:namespace "https://schema.org/"^^xsd:anyURI ;
            sh:prefix "schema" ] .

nen2660: sh:declare [ sh:namespace "https://w3id.org/nen2660/def#"^^xsd:anyURI ;
            sh:prefix "nen2660" ] .

rdfs: sh:declare [ sh:namespace "http://www.w3.org/2000/01/rdf-schema#"^^xsd:anyURI ;
            sh:prefix "rdfs" ] .

owl: sh:declare [ sh:namespace "http://www.w3.org/2002/07/owl#"^^xsd:anyURI ;
            sh:prefix "owl" ] .

ex: sh:declare [ sh:namespace "http://example.org/example#"^^xsd:anyURI ;
            sh:prefix "ex" ] .

