@prefix bm: <http://www.laces.tech/publication/ns/semmtech/live/laces/schema/blueprint-manager/> .
@prefix bs: <https://w3id.org/def/basicsemantics-owl#> .
@prefix dct: <http://purl.org/dc/terms/> .
@prefix ex: <http://example.org/example#> .
@prefix geo: <http://www.opengis.net/ont/geosparql#> .
@prefix kos: <http://www.laces.tech/publication/ns/semmtech/live/laces/schema/kos/> .
@prefix nen2660: <https://w3id.org/nen2660/def#> .
@prefix otl: <http://www.laces.tech/publication/ns/semmtech/live/laces/schema/otl-manager/> .
@prefix owl: <http://www.w3.org/2002/07/owl#> .
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .
@prefix schema: <https://schema.org/> .
@prefix sh: <http://www.w3.org/ns/shacl#> .
@prefix shapes: <http://www.laces.tech/publication/ns/semmtech/live/laces/schema/shapes/> .
@prefix skos: <http://www.w3.org/2004/02/skos/core#> .
@prefix specifications: <http://www.laces.tech/publication/ns/semmtech/live/laces/schema/specifications/> .
@prefix xsd: <http://www.w3.org/2001/XMLSchema#> .

ex:ConvertAspectWithRole a sh:NodeShape ;
    sh:rule [ a sh:SPARQLRule ;
            sh:construct """	
			CONSTRUCT {
				?tgtAspect a ?tgtPropertyType .
				?tgtAspect rdfs:subPropertyOf ?tgtParent .
				?tgtAspect rdfs:range ?tgtRangeDatatype .
				?tgtAspect skos:prefLabel ?tgtAspectPrefName .
				?tgtAspect skos:prefLabel ?tgtAspectAltName .
				?tgtAspect skos:definition ?tgtAspectDescription .
				?tgtAspect rdfs:seeAlso ?tgtAspectTerm .
				
				?tgtAspect skos:note ?tgtAspectNote .
				?tgtAspect skos:notation ?tgtAspectCode .
				?tgtAspect nen2660:abbreviation ?tgtAspectAbbreviation .
				
				?tgtAspect ?tgtAnnotationProperty ?tgtAnnotationValue .
				?tgtAnnotationProperty a owl:AnnotationProperty .
				?tgtAnnotationProperty skos:prefLabel ?tgtAnnotationName .
				?tgtAnnotationProperty rdfs:range xsd:string .

				?tgtAspectWithValue sh:property ?bnode1 .
				?tgtAspectWithValue a sh:NodeShape .
				?tgtAspectWithValue sh:targetClass ?tgtObject .

				?tgtShape sh:property ?bnode1 .
				?bnode1 sh:path ?tgtAspect .
				?bnode1 ?ShaclValueType ?tgtAspectDatatype . 

				# This is either sh:datatype ?tgtAspectDatatype or sh:class ?tgtAspectDatatype, depending on what is correct. ^^ 
				?bnode1 sh:class ?tgtAspectEnumeration .
				?bnode1 sh:hasValue ?tgtQualificationUri .
				?bnode1 sh:minCount ?tgtMinCardinality .
				?bnode1 sh:maxCount ?tgtMaxCardinality .
				?bnode1 sh:node ?tgtQuantityValueNode .

				
				?tgtQuantityValueNode a sh:NodeShape .
				?tgtQuantityValueNode sh:property ?bnode3 .
				?bnode3 sh:path ?tgtUnitRelation .
				?bnode3 sh:hasValue ?tgtUnit .
				?bnode3 sh:minCount 1 . 
				?bnode3 sh:maxCount 1 . # Een gekoppelde waarde mag hooguit 1 unit hebben. (Moet het minstens 1 zijn?)
				?tgtQuantityValueNode sh:property ?bnode4 .
				?bnode4 sh:path rdf:value . 
				?bnode4 sh:minCount 1 . # Een gekoppelde Quantification moet 1 en hooguit 1 getal hebben. 
				?bnode4 sh:maxCount 1 . 
				?bnode4 sh:datatype ?tgtDatatype .
				?bnode4 sh:hasValue ?tgtQuantificationValue .
				?tgtObject rdfs:subClassOf ?bnode2 .
				?bnode2 a owl:Restriction .
				?bnode2 owl:minCardinality ?tgtMinCardinality .
				?bnode2 owl:onProperty ?tgtAspect .
				?bnode2 owl:onClass ?tgtAspectEnumeration .
				?bnode2 owl:hasValue ?tgtQualificationUri .
				# ?tgtQualificationUri skos:prefLabel ?tgtQualificationName .
				# ?tgtQualificationUri skos:prefLabel ?tgtENQualificationName .
				?bnode2 owl:hasValue ?tgtQuantificationValue .
			}
			WHERE {
				BIND (BNODE() AS ?bnode1) .
				BIND (BNODE() AS ?bnode2) .
				
				?hasAspect otl:rel-Relation-toRole ?this .
				?hasAspect otl:rel-Relation-to ?aspect .
				?hasAspect otl:rel-Relation-from ?object .
				?aspect a otl:Aspect .
				# Check if the object has a defined shape, otherwise create a shape
				{
					?hasAspect otl:rel-Relation-from ?object .
					?object otl:rel-Conceptual-hasShape ?shape .
					BIND (URI(STR(?shape)) AS ?tgtShape) .
				}
				UNION
				{
					?hasAspect otl:rel-Relation-toRole ?this .
					?hasAspect otl:rel-Relation-from ?object .
					FILTER NOT EXISTS {
						?object otl:rel-Conceptual-hasShape ?shape .
					} .
					BIND (ex:createURI(CONCAT(ex:localname(?object), "-Shape")) AS ?tgtAspectWithValue) .
				} .
				# Check if the aspect has a parent and whether it is an internal or external link 
				OPTIONAL {
					?aspect otl:rel-Conceptual-isSpecializationOf ?parentAspect .
					OPTIONAL {
						?parentAspect otl:attr-Conceptual-name ?parentName .
						FILTER (LANG(?parentName) = "nl") .

						BIND (ex:createHumanReadableUri(?parentName) AS ?newParentAspectURI) .
					} .
					BIND (COALESCE(?newParentAspectURI, ?parentAspect) AS ?tgtParent) .
				} .
				# Check if the aspect is internal or external
				{
					?hasAspect otl:rel-Relation-toRole ?this .
					?hasAspect otl:rel-Relation-to ?aspect .
					?aspect a otl:Aspect .
					?aspect otl:attr-Conceptual-name ?aspectUriName .
					FILTER (LANG(?aspectUriName) = "nl") .

					BIND (ex:createHumanReadableUri(?aspectUriName) AS ?tgtAspect) .  
					BIND (URI(REPLACE(STR(?tgtAspect), "/def/", "/term/")) AS ?tgtAspectTerm ) .
				}
				UNION
				{
					?hasAspect otl:rel-Relation-toRole ?this .
					?hasAspect otl:rel-Relation-to ?aspect .
					FILTER NOT EXISTS {
						?aspect a otl:Aspect .
					} .
					BIND (?aspect AS ?tgtAspect) .
					BIND (URI(REPLACE(STR(?tgtAspect), "/def/", "/term/")) AS ?tgtAspectTerm ) .
				} .
				?object otl:attr-Conceptual-name ?objectUriName .
				FILTER (LANG(?objectUriName) = "nl") .

				BIND (ex:createHumanReadableUri(?objectUriName) AS ?tgtObject) .
				
				# Get all the descriptive information of the aspect
				?aspect shapes:sequence/rdf:_1 ?tgtAspectPrefName .
				OPTIONAL {
					?aspect otl:attr-Conceptual-name ?tgtAspectAltName .
					?aspect shapes:sequence/rdf:_1 ?tgtAspectPrefName .
					FILTER (?tgtAspectAltName != ?tgtAspectPrefName) .
				} .
				OPTIONAL {
					?aspect otl:attr-Conceptual-description ?tgtAspectDescription .
				} .
				OPTIONAL {
					?this otl:attr-Conceptual-note ?tgtAspectNote .
				} .
				OPTIONAL {
					?this otl:attr-Conceptual-code ?tgtAspectCode .
				} .
				OPTIONAL {
					?this otl:attr-Conceptual-abbreviation ?tgtAspectAbbreviation .
				} .
				OPTIONAL {
					?aspect otl:rel-Conceptual-isDescribedIn ?informationField .
					?informationField otl:attr-InformationField-value ?tgtAnnotationValue .
					?informationField otl:rel-InformationField-isClassifiedAs ?informationType .
					?informationType otl:attr-Conceptual-name ?tgtAnnotationName .
					BIND (ex:createURI(MD5(?tgtAnnotationName)) AS ?tgtAnnotationProperty) .
				} .
				OPTIONAL {
					?this otl:rel-RoleOfAspect-PossessedAspect-hasShapeAttribute ?attribute .
					?attribute bm:attr-Component-maxCardinality ?maxCardinality .
					?attribute bm:attr-Component-minCardinality ?minCardinality .
					BIND (STRDT(str(?minCardinality), xsd:integer) AS ?tgtMinCardinality) .
					BIND (STRDT(str(?maxCardinality), xsd:integer) AS ?tgtMaxCardinality) .
				} .
				# Convert aspects that expect a qualification value
				{
					?this otl:rel-RoleOfAspect-PossessedAspect-hasShapeAttribute ?attribute .
					?attribute bm:attr-Attribute-datatype ?tgtDatatype .
					FILTER NOT EXISTS {
						?this otl:rel-RoleOfAspect-PossessedAspect-isQualifiedAsOneOf ?aspectEnumeration .
					} .
					?this otl:rel-RoleOfAspect-PossessedAspect-isQualifiedAs-Qualification ?emptyQualification .
					?emptyQualification otl:attr-Conceptual-name ?EmptyQualificationName .
					FILTER (?EmptyQualificationName = "") .
					BIND (sh:datatype AS ?ShaclValueType ) .
					BIND (?tgtDatatype AS ?tgtAspectDatatype) .
					BIND (rdfs:Resource AS ?tgtRangeDatatype) .
					BIND (owl:ObjectProperty AS ?tgtPropertyType) .
				}
				UNION
				# Convert aspects that have a qualification value filled
				{
					?this otl:rel-RoleOfAspect-PossessedAspect-isQualifiedAs-Qualification ?qualification .
					FILTER NOT EXISTS {
						?this otl:rel-RoleOfAspect-PossessedAspect-hasShapeAttribute ?attribute .
					} .
					?qualification otl:attr-Conceptual-name ?tgtQualificationName .
					FILTER (?tgtQualificationName != "") .
					BIND(IF(CONTAINS(str(?tgtQualificationName), ","), STRLANG(STRBEFORE(?tgtQualificationName, ","), "nl"), STRLANG(?tgtQualificationName, "nl")) AS ?tgtNLQualificationName) .
					
					BIND (ex:createHumanReadableUri(?tgtNLQualificationName) AS ?qualificationURI) .
					BIND (URI(REPLACE(STR(?qualificationURI), "/def/", "/id/domeinwaarden/")) AS ?tgtQualificationUri ) .

					BIND (owl:ObjectProperty AS ?tgtPropertyType) .
				}
				UNION
				# Convert aspects with a qualification group
				{
					?this otl:rel-RoleOfAspect-PossessedAspect-isQualifiedAsOneOf ?aspectEnumeration .
					?this otl:rel-RoleOfAspect-PossessedAspect-isQualifiedAs-Qualification ?emptyQualification .
					?emptyQualification otl:attr-Conceptual-name ?EmptyQualificationName .
					FILTER (?EmptyQualificationName = "") .

					?aspectEnumeration otl:attr-Group-name ?EnumerationName . 
					BIND(IF(CONTAINS(str(?EnumerationName), "$"), STRBEFORE(?EnumerationName, "$"), ?EnumerationName) AS ?tgtEnumNames) .
					BIND(IF(CONTAINS(str(?tgtEnumNames), ","), STRLANG(STRBEFORE(?tgtEnumNames, ","), "nl"), STRLANG(?tgtEnumNames,"nl")) AS ?tgtEnumerationNLname) .
					
					BIND (ex:createHumanReadableUri(?tgtEnumerationNLname) AS ?tgtAspectEnumeration) .
					
					BIND (owl:ObjectProperty AS ?tgtPropertyType) .
					BIND (rdfs:Resource AS ?tgtRangeDatatype) .
				}
				UNION
				# Aspects with a quantification
				{
					# Aspects with a filled quantification value
					?this otl:rel-RoleOfAspect-PossessedAspect-isQualifiedAs-Quantification ?quantification .
					{
						?quantification otl:attr-Quantification-value ?tgtQuantificationValue .
					}
					UNION
					# Aspects that expect a quantification value
					{
						?this otl:rel-RoleOfAspect-PossessedAspect-hasShapeAttribute ?attribute .
						?this otl:rel-RoleOfAspect-PossessedAspect-isQualifiedAs-Quantification ?quantification .
						FILTER NOT EXISTS {
							?quantification otl:attr-Quantification-value ?quantificationValue .
						} .
						?attribute bm:attr-Attribute-datatype ?tgtDatatype .
					} .
					# Converting unit of measure
					# Always use nen2660:hasUnit (See https://confluence.semmtech.com/display/CON/NEN+2660+Stylesheet+%7C+Design+choices)
					?quantification otl:rel-Quantification-isQuantifiedOnScale ?unitOfMeasure .
					OPTIONAL { 
						?unitOfMeasure otl:rel-Conceptual-hasExternalLink ?externalLink1 .
						?externalLink1 otl:attr-ExternalLink-relation "isSameAs" .
						?externalLink1 otl:attr-ExternalLink-uri ?externalLinkUnitUri .
						FILTER regex(str(?externalLinkUnitUri), "http://qudt.org/schema/qudt/", "i") .
					}
					BIND (URI(STR(?unitOfMeasure)) AS ?implicitUnit) .
					BIND (COALESCE(URI(STR(?externalLinkUnitUri)), ?implicitUnit) AS ?tgtUnit) .
					BIND (URI(STR(?this)) AS ?tgtQuantityValueNode) .
					BIND (nen2660:hasUnit AS ?tgtUnitRelation) .
					
					BIND (BNODE() AS ?bnode3) .
					BIND (BNODE() AS ?bnode4) .
					BIND (owl:ObjectProperty AS ?tgtPropertyType) .
					BIND (sh:class AS ?ShaclValueType ) .
					BIND (nen2660:QuantityValue AS ?tgtRangeDatatype) .
					BIND (nen2660:QuantityValue AS ?tgtAspectDatatype) .
				} .
			} 
		""" ;
            sh:deactivated false ;
            sh:prefixes ex:,
                bm:,
                otl:,
                shapes:,
                rdf:,
                rdfs:,
                xsd:,
                owl:,
                skos:,
                sh:,
                schema:,
                nen2660: ] ;
    sh:targetClass otl:RoleOfAspect-PossessedAspect .

ex:ConvertAspectsWithoutRole a sh:NodeShape ;
    sh:rule [ a sh:SPARQLRule ;
            sh:construct """	
			CONSTRUCT {
				?tgtAspect a rdf:Property .
				?tgtAspect rdfs:subPropertyOf ?tgtParent .
				?tgtAspect skos:prefLabel ?tgtAspectPrefName .
				?tgtAspect skos:prefLabel ?tgtAspectAltName .
				?tgtAspect skos:definition ?tgtAspectDescription .
				?tgtAspect skos:note ?tgtAspectNote .
				?tgtAspect skos:notation ?tgtAspectCode .
				?tgtAspect nen2660:abbreviation ?tgtAspectAbbreviation .
				?tgtAspect rdfs:range ?tgtRangeDatatype .
				?tgtAspect ?tgtAnnotationProperty ?tgtAnnotationValue .
				?tgtAnnotationProperty a owl:AnnotationProperty .
				?tgtAnnotationProperty skos:prefLabel ?tgtAnnotationName .
				?tgtAnnotationProperty rdfs:range xsd:string .
				?tgtAspect rdfs:seeAlso ?tgtTerm .
			}
			WHERE {
				FILTER NOT EXISTS {
					?hasAspect otl:rel-Relation-to ?this .
				} .
				?this shapes:sequence/rdf:_1 ?tgtAspectPrefName .
				OPTIONAL {
					?this otl:attr-Conceptual-name ?tgtAspectAltName .
					?this shapes:sequence/rdf:_1 ?tgtAspectPrefName .
					FILTER (?tgtAspectAltName != ?tgtAspectPrefName) .
				} .
				# Check if the aspect has a parent and whether it is an internal or external link
				OPTIONAL {
					?this otl:rel-Conceptual-isSpecializationOf ?parentAspect .
					OPTIONAL {
						?parentAspect otl:attr-Conceptual-name ?parentName .
						FILTER (LANG(?parentName) = "nl") .

						BIND (ex:createHumanReadableUri(?parentName) AS ?newParentAspectURI) .
					} .
					BIND (COALESCE(?newParentAspectURI, ?parentAspect) AS ?tgtParent) .
				} .
				OPTIONAL {
					?this otl:attr-Conceptual-description ?tgtAspectDescription .
				} .
				OPTIONAL {
					?this otl:attr-Aspect-datatype ?tgtRangeDatatype
				} .
				OPTIONAL {
					?this otl:attr-Conceptual-note ?tgtAspectNote .
				} .
				OPTIONAL {
					?this otl:attr-Conceptual-code ?tgtAspectCode .
				} .
				OPTIONAL {
					?this otl:attr-Conceptual-abbreviation ?tgtAspectAbbreviation .
				} .

				# Get the information attribute
				OPTIONAL {
					?this otl:rel-Conceptual-isDescribedIn ?informationField .
					?informationField otl:attr-InformationField-value ?tgtAnnotationValue .
					?informationField otl:rel-InformationField-isClassifiedAs ?informationType .
					?informationType otl:attr-Conceptual-name ?tgtAnnotationName .
					BIND (CONCAT(?tgtAnnotationName, ": ", ?tgtAnnotationValue) AS ?tgtConceptualInformation) .
					FILTER (STRLEN(str(?tgtAnnotationValue)) > 0) .
					BIND (ex:createURI(MD5(?tgtAnnotationName)) AS ?tgtAnnotationProperty) .
				} .

				?this otl:attr-Conceptual-name ?aspectUriName .
				FILTER (LANG(?aspectUriName) = "nl") .

				BIND (ex:createHumanReadableUri(?aspectUriName) AS ?tgtAspect) .  
				BIND (URI(REPLACE(STR(?tgtAspect), "/def/", "/term/")) AS ?tgtTerm ) .
			}
			""" ;
            sh:deactivated false ;
            sh:prefixes ex:,
                bm:,
                otl:,
                shapes:,
                rdf:,
                rdfs:,
                xsd:,
                owl:,
                skos:,
                sh:,
                schema:,
                nen2660: ] ;
    sh:targetClass otl:Aspect .

ex:ConvertConceptuals a sh:NodeShape ;
    sh:rule [ a sh:SPARQLRule ;
            sh:construct """	
			CONSTRUCT {
			    ?tgtThis a owl:Class .
			    ?tgtThis rdfs:subClassOf ?tgtParentConcept .
			    ?tgtThis skos:prefLabel ?tgtConceptualPrefName .
			    ?tgtThis skos:prefLabel ?tgtConceptualAltName .
			    ?tgtThis skos:definition ?tgtConceptualDescription .
			    ?tgtThis skos:note ?tgtConceptualNote .
			    ?tgtThis skos:notation ?tgtConceptualCode .
			    ?tgtThis nen2660:abbreviation ?tgtConceptualAbbreviation .
				?tgtThis skos:notation ?rvvCodeValue .
			    ?tgtThis ?tgtAnnotationProperty ?tgtAnnotationValue .
			    ?tgtAnnotationProperty a owl:AnnotationProperty .
			    ?tgtAnnotationProperty skos:prefLabel ?tgtAnnotationNLname, ?tgtAnnotationENname .
			    ?tgtAnnotationProperty rdfs:range xsd:string .
				?tgtThis rdfs:seeAlso ?tgtExternalSourceLink .
				?tgtExternalSourceLink a schema:URL .
				?tgtExternalSourceLink dct:license ?license .
				?tgtExternalSourceLink schema:url ?tgtExternalSourceLink3 .
				?tgtThis nen2660:isDescribedBy ?tgtRelatedDocument .
				?tgtThis rdfs:seeAlso ?tgtTerm .
			}
			WHERE {
			# Only certain subclasses of otl:Conceptual should be converted into classes (Qualifications for example should not be converted into instances of owl:Class)
				?this a ?conceptual .
    			FILTER (?conceptual IN (otl:PhysicalObject, otl:GeometricalSpace, otl:Activity, otl:Function, otl:Document, otl:FunctionalSpace, otl:Objective, otl:Agent, otl:Event, otl:State, otl:Risk, otl:TimePeriod, otl:Matter)) .
			# If the concept is a specialization of another concept in the OTL, it should be modeled by a rdfs:subClassOf relation between the two concepts
				OPTIONAL {
			        ?this otl:rel-Conceptual-isSpecializationOf ?parentConceptual .
			        OPTIONAL {
						?parentConceptual otl:attr-Conceptual-name ?parentName .
						FILTER(LANG(?parentName) = "nl") .

						BIND (ex:createHumanReadableUri(?parentName) AS ?newParentConceptualURI) .
			        } .
			    } .
    			BIND (COALESCE(?newParentConceptualURI, ?parentConceptual) AS ?newParentConceptual) .
			# All concepts should be placed under a root concept. These root concepts are only created if it will contain at least one member
			# The top concepts of the OTL are placed under a root concept, all other concepts are placed under their parent
				OPTIONAL {
					?conceptual rdfs:seeAlso ?ntaTopConceptual .
				} .	
				OPTIONAL {
					?conceptual skos:altLabel ?tgtTopConceptualLabel .
					BIND (ex:createURI(?tgtTopConceptualLabel) AS ?lacesTopConceptual) .
				} .
				BIND (COALESCE(?ntaTopConceptual, ?lacesTopConceptual) AS ?tgtTopConceptual) .
				BIND (COALESCE(?newParentConceptual, ?tgtTopConceptual) AS ?tgtParentConcept) .
			
			# This section finds any names, the preferred name, descriptions, notes, codes and abbreviations of the concept (if applicable).
				?this shapes:sequence/rdf:_1 ?tgtConceptualPrefName .
				OPTIONAL {
					?this otl:attr-Conceptual-name ?tgtConceptualAltName .
					?this shapes:sequence/rdf:_1 ?tgtConceptualPrefName .
					FILTER (?tgtConceptualAltName != ?tgtConceptualPrefName) .
				} .
				OPTIONAL {
					?this otl:attr-Conceptual-description ?tgtConceptualDescription .
				} .
				OPTIONAL {
					?this otl:attr-Conceptual-note ?tgtConceptualNote .
				} .
				OPTIONAL {
					?this otl:attr-Conceptual-code ?tgtConceptualCode .
				} .
				OPTIONAL {
					?this otl:attr-Conceptual-abbreviation ?tgtConceptualAbbreviation .
				} .
			#This part handles the image links.
				OPTIONAL {
					?this otl:describes ?describesLink .
					BIND (URI(str(?describesLink)) AS ?describesURI) .
					BIND (STRDT(STR(?describesLink), xsd:anyURI) AS ?tgtExternalSourceLink) .
					OPTIONAL {
						FILTER (
							CONTAINS(str(?describesLink), "https://raw.githubusercontent.com/ndwnu/qgis-verkeersborden-style/")
						)
						BIND (<https://opensource.org/licenses/MIT> AS ?license) .						
					}
				}
			# This section finds any extra attributes of a concept that have been stored using the InformationField and InformationType classes. Each attribute is converted to one value by concatenating its InformationType and InformationField value.
				OPTIONAL {
					?this otl:rel-Conceptual-isDescribedIn ?informationField .
					?informationField otl:attr-InformationField-value ?tgtAnnotationValue .
					?informationField otl:rel-InformationField-isClassifiedAs ?informationType .
					?informationType otl:attr-Conceptual-name ?tgtAnnotationName .
					
					BIND (IF (CONTAINS(str(?tgtAnnotationName), ","), STRLANG(STRBEFORE(?tgtAnnotationName, ","), "nl"), ?tgtAnnotationName) AS ?tgtAnnotationNLname) .
					BIND (IF (CONTAINS(str(?tgtAnnotationName), ","), STRLANG(STRAFTER(?tgtAnnotationName, ","), "en"), ?undefined) AS ?tgtAnnotationENname) .

					BIND(IF(str(?tgtAnnotationName) = "rvvCode", ?tgtAnnotationValue, ?undefined) AS ?rvvCodeValue) .
					BIND (CONCAT(?tgtAnnotationName, ": ", ?tgtAnnotationValue) AS ?tgtConceptualInformation) .
					FILTER (STRLEN(str(?tgtAnnotationValue)) > 0) .
					BIND (IF (str(?tgtAnnotationName) != "rvvCode", ex:createURI(MD5(?tgtAnnotationName)), ?undefined) AS ?tgtAnnotationProperty) .					
				} .
				
			# This part is to find the otl:Document-isDescribedIn-Document relation
				OPTIONAL {
					?relation a otl:Document-isDescribedIn-Document .
					?relation otl:rel-Relation-from ?this .
					?relation otl:rel-Relation-to ?relatedDocument .
					?relatedDocument otl:attr-Conceptual-name ?relatedDocName .
					FILTER (LANG(?relatedDocName) = "nl") .

					BIND (ex:createHumanReadableUri(?relatedDocName) AS ?tgtRelatedDocument) .  
				}

				?this otl:attr-Conceptual-name ?conceptUriName .
				FILTER (LANG(?conceptUriName) = "nl") .

				BIND (ex:createHumanReadableUri(?conceptUriName) AS ?tgtThis) .  
				BIND (URI(REPLACE(STR(?tgtThis), "/def/", "/term/")) AS ?tgtTerm ) .
			}
			""" ;
            sh:deactivated false ;
            sh:prefixes ex:,
                dct:,
                bm:,
                otl:,
                shapes:,
                rdf:,
                rdfs:,
                xsd:,
                owl:,
                skos:,
                sh:,
                schema:,
                nen2660: ] ;
    sh:targetClass otl:Conceptual .

ex:ConvertExternalSource a sh:NodeShape ;
    sh:rule [ a sh:SPARQLRule ;
            sh:construct """	
			CONSTRUCT {
				?childConceptual rdfs:subClassOf ?tgtThis .
				?tgtThis owl:equivalentClass ?tgtSameAsExternalURI .
				?tgtThis skos:related ?tgtRelatedToExternalURI .
				?tgtThis ?shallBeCompliantWith ?tgtIsCompliantWithExternalURI .
			}
			WHERE {
				?this a ?conceptual .
				FILTER (?conceptual != otl:Aspect) .
				?this shapes:sequence/rdf:_1 ?name .
				# ?this otl:attr-Conceptual-name ?name .
				# FILTER(LANG(?name) = "nl") .
				OPTIONAL {
					?childConceptual otl:rel-Conceptual-isSpecializationOf ?this .
					FILTER NOT EXISTS {
						?childConceptual otl:attr-Conceptual-name ?childName .
					} .
				} .
				# OPTIONAL {  # Only used for QUDT Units (see convertUnitOfMeasure)
				# 	?this otl:rel-Conceptual-hasExternalLink ?1externalRelation .
				# 	?1externalRelation a otl:ExternalLink .
				# 	?1externalRelation otl:attr-ExternalLink-relation "isSameAs" .
				# 	?1externalRelation otl:attr-ExternalLink-uri ?sameAsExternalURI .
				# 	FILTER (!regex(str(?sameAsExternalURI), "http://qudt.org/schema/qudt/", "i")) .
				# 	BIND (URI(str(?sameAsExternalURI)) AS ?tgtSameAsExternalURI) .
				# } .
				OPTIONAL {
					?this otl:rel-Conceptual-hasExternalLink ?2externalRelation .
					?2externalRelation a otl:ExternalLink .
					?2externalRelation otl:attr-ExternalLink-relation "isRelatedTo" .
					?2externalRelation otl:attr-ExternalLink-uri ?relatedToExternalURI .
					BIND (IF(
						CONTAINS(STR(?relatedToExternalURI), "https://wetten.overheid.nl/"), 
						STRDT(STR(?relatedToExternalURI), xsd:anyURI), 
						URI(str(?relatedToExternalURI))) AS ?tgtRelatedToExternalURI) .
					# BIND (URI(str(?relatedToExternalURI)) AS ?tgtRelatedToExternalURI) .
				} .
				OPTIONAL {
					?this otl:rel-Conceptual-hasExternalLink ?3externalRelation .
					?3externalRelation a otl:ExternalLink .
					?3externalRelation otl:attr-ExternalLink-relation "isCompliantWith" .
					?3externalRelation otl:attr-ExternalLink-uri ?isCompliantWithExternalURI .
					BIND (URI(str(?isCompliantWithExternalURI)) AS ?tgtIsCompliantWithExternalURI) .
					BIND (ex:createURI("shallBeCompliantWith") AS ?shallBeCompliantWith) .
				} .

				BIND (ex:createHumanReadableUri(?name) AS ?tgtThis) .
			}
			""" ;
            sh:deactivated false ;
            sh:prefixes ex:,
                bm:,
                otl:,
                shapes:,
                rdf:,
                rdfs:,
                xsd:,
                owl:,
                skos:,
                sh:,
                schema:,
                nen2660: ] ;
    sh:targetClass otl:Conceptual .

ex:ConvertExternalSourceAspect a sh:NodeShape ;
    sh:rule [ a sh:SPARQLRule ;
            sh:construct """	
			CONSTRUCT {
				?tgtAspect owl:equivalentProperty ?tgtSameAsExternalURI .
				?tgtAspect skos:related ?tgtRelatedToExternalURI .
			}
			WHERE {
				?aspect otl:rel-Conceptual-hasExternalLink ?this .
				?aspect a otl:Aspect .
				?aspect otl:attr-Conceptual-name ?name .
				FILTER(LANG(?name) = "nl") .
				# OPTIONAL {  # Only used for QUDT units
				# 	?aspect otl:rel-Conceptual-hasExternalLink ?1externalRelation .
				# 	?1externalRelation a otl:ExternalLink .
				# 	?1externalRelation otl:attr-ExternalLink-relation "isSameAs" .
				# 	?1externalRelation otl:attr-ExternalLink-uri ?sameAsExternalURI .
				# 	BIND (URI(str(?sameAsExternalURI)) AS ?tgtSameAsExternalURI) .
				# } .
				OPTIONAL {
					?aspect otl:rel-Conceptual-hasExternalLink ?2externalRelation .
					?2externalRelation a otl:ExternalLink .
					?2externalRelation otl:attr-ExternalLink-relation "isRelatedTo" .
					?2externalRelation otl:attr-ExternalLink-uri ?relatedToExternalURI .
					BIND (IF(
						CONTAINS(STR(?relatedToExternalURI), "https://wetten.overheid.nl/"), 
						STRDT(STR(?relatedToExternalURI), xsd:anyURI), 
						URI(str(?relatedToExternalURI))) AS ?tgtRelatedToExternalURI) .
				} .
				
				BIND (ex:createHumanReadableUri(?name) AS ?tgtAspect) .
			}
			""" ;
            sh:deactivated false ;
            sh:prefixes ex:,
                bm:,
                otl:,
                shapes:,
                rdf:,
                rdfs:,
                xsd:,
                owl:,
                skos:,
                sh:,
                schema:,
                nen2660: ] ;
    sh:targetClass otl:ExternalLink .

ex:ConvertFunctionalSpace a sh:NodeShape ;
    sh:rule [ a sh:SPARQLRule ;
            sh:construct """	
			CONSTRUCT {
				?tgtThis rdfs:subClassOf geo:Feature .
			}
			WHERE {
				?this a otl:FunctionalSpace .
				?this otl:attr-Conceptual-name ?name .
				FILTER (LANG(?name) = "nl") .

				BIND (ex:createHumanReadableUri(?name) AS ?tgtThis) . 
			} 
		""" ;
            sh:deactivated false ;
            sh:prefixes ex:,
                otl:,
                geo:,
                rdfs:,
                sh: ] ;
    sh:targetClass otl:FunctionalSpace .

ex:ConvertGroupForQualifications a sh:NodeShape ;
    sh:rule [ a sh:SPARQLRule ;
            sh:construct """	
			CONSTRUCT {
				# ?tgtList a rdf:List .
				# ?tgtList rdf:first ?tgtElementUri .
				# ?tgtElementUri a ?tgtThis .
				# ?tgtElementUri skos:prefLabel ?tgtNLname .
				# ?tgtElementUri skos:prefLabel ?tgtENname .
				# ?tgtElementUri skos:definition ?nlDescription .
				# ?tgtElementUri skos:definition ?enDescription .
				# ?tgtElementUri rdfs:seeAlso ?link .
				# ?link skos:prefLabel ?linkName .
				# ?tgtList rdf:rest ?tgtRestList .
				?tgtThis a owl:Class .
				?tgtThis rdfs:subClassOf nen2660:EnumerationType .
				?tgtThis skos:prefLabel ?tgtEnumerationNLname .
				?tgtThis skos:prefLabel ?tgtEnumerationENname .
				?tgtThis skos:definition ?enumnlDescription .
				?tgtThis skos:definition ?enumenDescription .
				?tgtThis rdfs:seeAlso ?tgtTerm .
				# ?tgtThis a sh:NodeShape .
				# ?tgtThis sh:in ?tgtListFirst .
				# ?tgtThis owl:oneOf ?tgtListFirst .
			}
			WHERE {
				?possessedAspect otl:rel-RoleOfAspect-PossessedAspect-isQualifiedAsOneOf ?this .
				?possessedAspect otl:rel-RoleOfAspect-PossessedAspect-isQualifiedAs-Qualification ?emptyQualification .
				?emptyQualification otl:attr-Conceptual-name "" .
				{
					SELECT ?this ?qualification ?tgtElementName ((COUNT(?predecessor)) AS ?elementIndex)
					WHERE {
						?this a otl:GroupForQualifications .
						?this otl:rel-Group-isCollectionFor ?qualification .
						OPTIONAL {
							?this otl:rel-Group-isCollectionFor ?predecessor .
							FILTER (str(?predecessor) < str(?qualification)) .
						} .
						?qualification otl:attr-Conceptual-name ?tgtElementName .
					}
					GROUP BY ?this ?qualification ?tgtElementName
				} .
				{
					SELECT ?this ?qualification ?tgtElementName ?tgtElementDescription ((COUNT(?successor)) AS ?isLastElement)
					WHERE {
						?this a otl:GroupForQualifications .
						?this otl:rel-Group-isCollectionFor ?qualification .
						OPTIONAL {
							?this otl:rel-Group-isCollectionFor ?successor .
							FILTER (str(?successor) > str(?qualification)) .
						} .
						?qualification otl:attr-Conceptual-name ?tgtElementName .
						OPTIONAL {
							?qualification otl:attr-Conceptual-description ?tgtElementDescription .
						} .
					}
					GROUP BY ?this ?qualification ?tgtElementName ?tgtElementDescription
				} .

				BIND(IF(CONTAINS(str(?tgtElementName), ","), STRLANG(STRBEFORE(?tgtElementName, ","), "nl"), STRLANG(?tgtElementName, "nl")) AS ?tgtNLname) .
  				BIND(IF(CONTAINS(str(?tgtElementName), ","), STRLANG(STRAFTER(?tgtElementName, ","), "en"), ?undefined) AS ?tgtENname) .
				# BIND(IF(REGEX(?tgtElementName, '^"([^"]*)",'), STRLANG(REPLACE(?tgtElementName, '^"([^"]*)",".*$', '$1'), "nl"), STRLANG(?tgtElementName, "nl")) AS ?tgtNLnameQuoted) .
				# BIND(IF(REGEX(?tgtElementName, '^"([^"]*)",'), STRLANG(REPLACE(?tgtElementName, '^".*","([^"]*)"$', '$1'), "en"), ?undefined) AS ?tgtENnameQuoted) .
				# BIND(COALESCE(?tgtNLnameQuoted, ?nlName) AS ?tgtNLname) .
				# BIND(COALESCE(?tgtENnameQuoted, ?enName) AS ?tgtENname) .

				BIND(IF(CONTAINS(str(?tgtElementDescription), "$"), STRBEFORE(?tgtElementDescription, "$"), ?tgtElementDescription) AS ?descriptions) .
  				BIND(IF(CONTAINS(str(?tgtElementDescription), "$"), STRAFTER(?tgtElementDescription, "$"), ?undefined) AS ?rest) .
				BIND(COALESCE(?descriptions, ?tgtElementDescription) AS ?tgtdescriptions)
  				BIND(IF(REGEX(?tgtdescriptions, '^"([^"]*)",'), STRLANG(REPLACE(?tgtdescriptions, '^"([^"]*)",".*$', '$1'), "nl"), STRLANG(?tgtdescriptions, "nl")) AS ?nlDescription) .
				BIND(IF(REGEX(?tgtdescriptions, '^"([^"]*)",'), STRLANG(REPLACE(?tgtdescriptions, '^".*","([^"]*)"$', '$1'), "en"), ?undefined) AS ?enDescription) .

				BIND(IF(CONTAINS(str(?rest), "]"), STRAFTER(STRBEFORE(?rest, "]"), "["), ?undefined) AS ?linkName) .
				BIND(IF(CONTAINS(str(?rest), "]"), STRAFTER(	STRBEFORE(STRAFTER(?rest, "]"), ")")	,"(") , ?undefined) AS ?strlink) .
				BIND (STRDT(STR(?strlink), xsd:anyURI) AS ?link) .

				# GroupForQualification
				?this otl:attr-Group-name ?EnumerationName .
				BIND(IF(CONTAINS(str(?EnumerationName), "$"), STRBEFORE(?EnumerationName, "$"), ?EnumerationName) AS ?tgtEnumNames) .
  				BIND(IF(CONTAINS(str(?EnumerationName), "$"), STRAFTER(?EnumerationName, "$"), ?undefined) AS ?tgtEnumDescriptions) .
				# BIND(COALESCE(?EnumNames, ?EnumerationName) AS ?tgtEnumNames)

				BIND(IF(CONTAINS(str(?tgtEnumNames), ","), STRLANG(STRBEFORE(?tgtEnumNames, ","), "nl"), STRLANG(?tgtEnumNames,"nl")) AS ?tgtEnumerationNLname) .
  				BIND(IF(CONTAINS(str(?tgtEnumNames), ","), STRLANG(STRAFTER(?tgtEnumNames, ","), "en"), ?undefined) AS ?tgtEnumerationENname) .
				BIND(IF(REGEX(?tgtEnumDescriptions, '^"([^"]*)",'), STRLANG(REPLACE(?tgtEnumDescriptions, '^"([^"]*)",".*$', '$1'), "nl"), STRLANG(?tgtEnumDescriptions, "nl")) AS ?enumnlDescription) .
				BIND(IF(REGEX(?tgtEnumDescriptions, '^"([^"]*)",'), STRLANG(REPLACE(?tgtEnumDescriptions, '^".*","([^"]*)"$', '$1'), "en"), ?undefined) AS ?enumenDescription) .
				
				BIND (ex:createHumanReadableUri(?tgtEnumerationNLname) AS ?tgtThis) .
				
				BIND (ex:createHumanReadableUri(?tgtNLname) AS ?tgtElementUri) . 

				BIND (CONCAT(str(?tgtThis), "-list-") AS ?listBase) .
				BIND (IRI(CONCAT(?listBase, "0")) AS ?tgtListFirst) .
				BIND (IRI(CONCAT(?listBase, str(?elementIndex))) AS ?tgtList) .
				BIND (IF((?isLastElement = 0), rdf:nil, URI(CONCAT(?listBase, str((?elementIndex + 1))))) AS ?tgtRestList) .
				BIND (URI(REPLACE(STR(?tgtThis), "/def/", "/term/")) AS ?tgtTerm ) .
			}
			""" ;
            sh:deactivated false ;
            sh:prefixes ex:,
                bm:,
                otl:,
                shapes:,
                rdf:,
                rdfs:,
                xsd:,
                owl:,
                skos:,
                sh:,
                schema:,
                nen2660: ] ;
    sh:targetClass otl:GroupForQualifications .

ex:ConvertGroups a sh:NodeShape ;
    sh:rule [ a sh:SPARQLRule ;
            sh:construct """	
			CONSTRUCT {
				?tgtThis a rdfs:Container .
				?tgtThis skos:prefLabel ?tgtNLGroupname .
				?tgtThis skos:prefLabel ?tgtENGroupname .
				?tgtThis rdfs:member ?tgtConceptual .
				?tgtThis rdfs:member ?tgtPartGroup .
				?tgtThis rdfs:seeAlso ?tgtTerm .
			}
			WHERE {
			# otl:GroupForQualifications is a subclass of otl:Group. Its instances should not be used in this conversion
				FILTER NOT EXISTS {
					?this a otl:GroupForQualifications .
				} .
			# Find the conceptuals that are part of the group
				?this otl:rel-Group-isCollectionFor ?conceptual .
				?conceptual otl:attr-Conceptual-name ?name .
				FILTER(LANG(?name) = "nl") .
				
				BIND (ex:createHumanReadableUri(?name) AS ?tgtConceptual) . 
			# Find the group names if applicable
				OPTIONAL {
					?this otl:attr-Group-name ?tgtGroupName .
					FILTER(LANG(?tgtGroupName) = "nl") .
				} .
			# Find groups that are part of this group, these will be added as group members, just like conceptuals
				OPTIONAL {
					?this otl:rel-Group-isWholeFor ?partGroup .
					?partGroup otl:attr-Group-name ?tgtPartGroupName .
					FILTER(LANG(?tgtPartGroupName) = "nl") .
					
					BIND (ex:createHumanReadableUri(?tgtPartGroupName) AS ?tgtPartGroup) .  
				} .
				
				BIND (ex:createHumanReadableUri(?tgtGroupName) AS ?tgtThis) .
				BIND (URI(REPLACE(STR(?tgtThis), "/def/", "/term/")) AS ?tgtTerm ) .
			}
			""" ;
            sh:deactivated false ;
            sh:prefixes ex:,
                bm:,
                otl:,
                shapes:,
                rdf:,
                rdfs:,
                xsd:,
                owl:,
                skos:,
                sh:,
                schema:,
                nen2660: ] ;
    sh:targetClass otl:Group .

ex:ConvertRelations a sh:NodeShape ;
    sh:rule [ a sh:SPARQLRule ;
            sh:construct """	
			CONSTRUCT {
				?tgtFrom rdfs:subClassOf ?bnode1 .
				?bnode1 a owl:Restriction .
				?bnode1 owl:onProperty ?tgtRelation .
				?bnode1 owl:onClass ?tgtTo .
				?bnode1 owl:minQualifiedCardinality ?tgtMinCardinality .
				?bnode1 owl:maxQualifiedCardinality ?tgtMaxCardinality .
				?tgtShapeFromLaces a sh:NodeShape .
				?tgtShapeFromLaces sh:targetClass ?tgtFrom .
				?tgtShapeFromLaces sh:property ?bnode2 .
				?bnode2 sh:qualifiedValueShape ?bnode3 .
				?bnode3 sh:class ?tgtTo .
				?bnode2 sh:path ?tgtRelation .
				?bnode2 sh:qualifiedMinCount ?tgtMinCardinality .
				?bnode2 sh:qualifiedMaxCount ?tgtMaxCardinality .
			}
			WHERE {
				BIND (BNODE() AS ?bnode1) .
				BIND (BNODE() AS ?bnode2) .
				BIND (BNODE() AS ?bnode3) .
				?this otl:rel-Relation-from ?from .
				?from otl:attr-Conceptual-name ?fromName .
				FILTER (LANG(?fromName) = "nl") .

				BIND (ex:createHumanReadableUri(?fromName) AS ?fromUri) .
				?this otl:rel-Relation-to ?to .
				?to otl:attr-Conceptual-name ?toName .
				FILTER (LANG(?toName) = "nl") .

				BIND (ex:createHumanReadableUri(?toName) AS ?toUri) .
				?this a ?lacesRelation .
				FILTER NOT EXISTS { 
					?lacesRelation rdfs:subClassOf otl:hasAspect .
				}
				FILTER NOT EXISTS { 
					?lacesRelation rdfs:subClassOf otl:isWholeFor .
				}
				OPTIONAL {
					?this otl:attr-Relation-minCardinality ?minCardinality .
				} .
				OPTIONAL {
					?this otl:attr-Relation-maxCardinality ?tgtMaxCardinality .
				} .
				OPTIONAL { 
					?lacesRelation rdfs:seeAlso ?bsRelation0 . 
				}
				OPTIONAL {
					?lacesRelation rdfs:subClassOf ?lacesTopRelation .
					FILTER(STRSTARTS(STR(?lacesTopRelation), "http://www.laces.tech/publication/")) .
					?lacesTopRelation rdfs:seeAlso ?bsRelation1 .
				} .
				OPTIONAL {
					?lacesRelation rdfs:subClassOf ?lacesTopRelation .
					FILTER(STRSTARTS(STR(?lacesTopRelation), "http://www.laces.tech/publication/")) .
					?lacesTopRelation skos:altLabel ?relationName .
					BIND (ex:createURI(?relationName) AS ?bsRelation2) .
				} .
				OPTIONAL {
					?from otl:rel-Conceptual-hasShape ?shapeFrom .
					BIND (?shapeFrom AS ?shapeFromReused) .
				} .
				BIND (COALESCE(?shapeFromReused, ex:createURI(CONCAT(ex:localname(?from), "-Shape"))) AS ?tmpShapeFrom) .
				OPTIONAL {
					?lacesRelation rdfs:subClassOf ?lacesTopRelation .
					FILTER(STRSTARTS(STR(?lacesTopRelation), "http://www.laces.tech/publication/")) .
					?lacesTopRelation owl:inverseOf ?inverseRelationStr .
					BIND (URI(?inverseRelationStr) AS ?inverseRelation) .
				} .
				OPTIONAL {
					?to otl:rel-Conceptual-hasShape ?shapeTo .
					BIND (?shapeTo AS ?shapeToReused) .
				} .
				BIND (COALESCE(?shapeToReused, ex:createURI(CONCAT(ex:localname(?to), "-Shape"))) AS ?tmpShapeTo) .
				
				BIND (IF(bound(?inverseRelation) && !bound(?bsRelation0), ?toUri, ?fromUri) AS ?tgtFrom) .
				BIND (IF(bound(?inverseRelation) && !bound(?bsRelation0), ?fromUri, ?toUri) AS ?tgtTo) .
				BIND (IF(bound(?inverseRelation) && !bound(?bsRelation0), ?tmpShapeTo,?tmpShapeFrom) AS ?tgtShapeFromLaces) .
				BIND (IF(bound(?minCardinality), ?minCardinality, IF(bound(?maxCardinality), ?null, "0"^^xsd:nonNegativeInteger)) AS ?tgtMinCardinality) .
				BIND (COALESCE(?bsRelation0, ?inverseRelation, ?bsRelation1, ?bsRelation2) AS ?tgtRelation) .
			}
			""" ;
            sh:deactivated false ;
            sh:prefixes ex:,
                bm:,
                otl:,
                shapes:,
                rdf:,
                rdfs:,
                xsd:,
                owl:,
                skos:,
                sh:,
                schema:,
                nen2660: ] ;
    sh:targetClass otl:Relation .

ex:ConvertShapes a sh:NodeShape ;
    sh:rule [ a sh:SPARQLRule ;
            sh:construct """	
			CONSTRUCT {
				?tgtThis a sh:NodeShape .
				?tgtThis sh:targetClass ?tgtShapeObject .
				?tgtThis skos:prefLabel ?tgtNLObjectName .
				?tgtThis skos:prefLabel ?tgtENObjectName .
				?tgtThis skos:definition ?tgtObjectDescription .
				?tgtThis skos:note ?tgtObjectNote .
			}
			WHERE {
				?shapeObject otl:rel-Conceptual-hasShape ?this .
				?shapeObject otl:attr-Conceptual-name ?objectName .
				FILTER (LANG(?objectName) = "nl") .

				BIND (ex:createHumanReadableUri(?objectName) AS ?tgtShapeObject) .
				OPTIONAL {
					?this bm:attr-ShapeElement-name ?tgtObjectName .
					BIND(IF(CONTAINS(str(?tgtObjectName), ","), STRLANG(STRBEFORE(?tgtObjectName, ","), "nl"), STRLANG(?tgtObjectName, "nl")) AS ?tgtNLObjectName) .
  					BIND(IF(CONTAINS(str(?tgtObjectName), ","), STRLANG(STRAFTER(?tgtObjectName, ","), "en"), ?undefined) AS ?tgtENObjectName) .
				} .
				OPTIONAL {
					?this bm:attr-ShapeElement-description ?tgtObjectDescription .
				} .
				OPTIONAL {
					?this bm:attr-ShapeElement-note ?tgtObjectNote .
				} .
				BIND (URI(STR(?this)) AS ?tgtThis) .
			}
			""" ;
            sh:deactivated false ;
            sh:prefixes ex:,
                bm:,
                otl:,
                shapes:,
                rdf:,
                rdfs:,
                xsd:,
                owl:,
                skos:,
                sh:,
                schema:,
                nen2660: ] ;
    sh:targetClass bm:Shape .

ex:ConvertUnitOfMeasure a sh:NodeShape ;
    sh:rule [ a sh:SPARQLRule ;
            sh:construct """	
			CONSTRUCT {
				?tgtUnitOfMeasure a <http://qudt.org/schema/qudt/Unit> .
			}
			WHERE {
				?this a otl:UnitOfMeasure .
				?this otl:rel-Conceptual-hasExternalLink ?externalLink .
				?externalLink otl:attr-ExternalLink-relation "isSameAs" .
				?externalLink otl:attr-ExternalLink-uri ?externalUnitUri .
				FILTER (CONTAINS(STR(?externalUnitUri), "http://qudt.org/schema/qudt/")) .
				BIND (URI(STR(?externalUnitUri)) AS ?tgtUnitOfMeasure) .
			}
			""" ;
            sh:deactivated false ;
            sh:prefixes ex:,
                bm:,
                otl:,
                shapes:,
                rdf:,
                rdfs:,
                xsd:,
                owl:,
                skos:,
                sh:,
                schema:,
                nen2660: ] ;
    sh:targetClass otl:UnitOfMeasure .

ex:ConvertWholeFor a sh:NodeShape ;
    sh:rule [ a sh:SPARQLRule ;
            sh:construct """	
			CONSTRUCT {
				?tgtShapeWhole sh:property ?bnode1 .
				?tgtShapeWhole a sh:NodeShape .
				?tgtShapeWhole sh:targetClass ?tgtObjectWhole .
				?bnode1 sh:path nen2660:hasPart .
				?bnode1 sh:qualifiedMinCount ?tgtMinCardinalityINT .
				?bnode1 sh:qualifiedMaxCount ?tgtPartMaxCardinalityINT .
				?bnode1 sh:qualifiedValueShape ?bnode2 .
				?bnode2 sh:class ?tgtObjectPart .
				?tgtObjectWhole rdfs:subClassOf ?bnode3 .
				?bnode3 a owl:Restriction .
				?bnode3 owl:onProperty nen2660:hasPart .
				?bnode3 owl:minQualifiedCardinality ?tgtMinCardinality .
				?bnode3 owl:maxQualifiedCardinality ?tgtPartMaxCardinality .
				?bnode3 owl:onClass ?tgtObjectPart .
			}
			WHERE {
				BIND (BNODE() AS ?bnode1) .
				BIND (BNODE() AS ?bnode2) .
				BIND (BNODE() AS ?bnode3) .
				?this a ?thisType .
				FILTER CONTAINS(str(?thisType), "isWholeFor") .
				?this otl:rel-Relation-from ?objectWhole .
				# Check if the ?objectWhole has a name (if not then this object is an external source and the URI should stay the same)
				OPTIONAL {
					?objectWhole otl:attr-Conceptual-name ?objectWholeName .
					FILTER (LANG(?objectWholeName) = "nl") .

					BIND (ex:createHumanReadableUri(?objectWholeName) AS ?objectWholeURI) .
				} .
				BIND (COALESCE(?objectWholeURI, ?objectWhole) AS ?tgtObjectWhole) .
				
				?this otl:rel-Relation-to ?objectPart .
				# Check if ?objectPart has a name (same reason ?objectWhole)
				OPTIONAL {
					?objectPart otl:attr-Conceptual-name ?objectPartName .
					FILTER (LANG(?objectPartName) = "nl") .

					BIND (ex:createHumanReadableUri(?objectPartName) AS ?objectPartURI) .
				} .
				BIND (COALESCE(?objectPartURI, ?objectPart) AS ?tgtObjectPart) .
				# Check of the ?objectWhole has a shape, if yes, reuse. If not create shape
				OPTIONAL {
					?objectWhole otl:rel-Conceptual-hasShape ?shapeWhole .
					BIND (URI(STR(?shapeWhole)) AS ?tgtShapeWholeReused) .
				} .
				BIND (COALESCE(?tgtShapeWholeReused, ex:createURI(CONCAT(ex:localname(?objectWhole), "-Shape"))) AS ?tgtShapeWhole) .
				# Retrieve the minimum cardinality
				OPTIONAL {
					?this otl:attr-Relation-minCardinality ?partMinCardinality .
				} .
				# Find the maximum cardinality
				OPTIONAL {
					?this otl:attr-Relation-maxCardinality ?tgtPartMaxCardinality .
				} .
				BIND (IF((!bound(?partMinCardinality)), IF((!bound(?tgtPartMaxCardinality)), "0"^^xsd:nonNegativeInteger, ?undefined), ?partMinCardinality) AS ?tgtMinCardinality) .
				BIND (STRDT(str(?tgtMinCardinality), xsd:integer) AS ?tgtMinCardinalityINT) .
				BIND (STRDT(str(?tgtPartMaxCardinality), xsd:integer) AS ?tgtPartMaxCardinalityINT) .
			}
			""" ;
            sh:deactivated false ;
            sh:prefixes ex:,
                bm:,
                otl:,
                shapes:,
                rdf:,
                rdfs:,
                xsd:,
                owl:,
                skos:,
                sh:,
                schema:,
                nen2660: ] ;
    sh:targetClass otl:isWholeFor .

ex:CreateOntology a sh:NodeShape ;
    sh:rule [ a sh:SPARQLRule ;
            sh:construct """	
			CONSTRUCT {
			    ?tgtInferredOntology a owl:Ontology .
			    ?tgtInferredOntology owl:imports <https://w3id.org/nen2660/def#> .
			    ?tgtInferredOntology dct:date ?tgtVersionDate .
			    ?tgtInferredOntology skos:prefLabel ?tgtOntologyName .
			    ?tgtInferredOntology rdfs:comment ?tgtOntologyDescription .
			    ?tgtPhysicalObject a owl:Class .
			    ?tgtPhysicalObject skos:prefLabel "physical object"@en .
			    ?tgtPhysicalObject skos:prefLabel "fysiek object"@nl .
			    ?tgtActivity a owl:Class .
			    ?tgtActivity skos:prefLabel "activity"@en .
			    ?tgtActivity skos:prefLabel "activiteit"@nl .
			    ?tgtFunction a owl:Class .
			    ?tgtFunction skos:prefLabel "function"@en .
			    ?tgtFunction skos:prefLabel "functie"@nl .
			    ?tgtFunction rdfs:subClassOf ?tgtActivity .
			    ?tgtObjective a owl:Class .
			    ?tgtObjective skos:prefLabel "objective"@en .
			    ?tgtObjective skos:prefLabel "doel"@nl .
			    ?tgtObjective rdfs:subClassOf nen2660:State .
			    ?tgtRisk a owl:Class .
			    ?tgtRisk skos:prefLabel "risk"@en .
			    ?tgtRisk skos:prefLabel "risico"@nl .
			    ?tgtRisk rdfs:subClassOf ?tgtActivity .
			    ?tgtAgent a owl:Class .
			    ?tgtAgent skos:prefLabel "agent"@en .
			    ?tgtAgent skos:prefLabel "actor"@nl .
			    ?tgtAgent rdfs:subClassOf ?tgtPhysicalObject .
			    ?tgtSpatialRegion a owl:Class .
			    ?tgtSpatialRegion skos:prefLabel "Geometric entity"@en .
			    ?tgtSpatialRegion skos:prefLabel "geometrische entiteit"@nl .
			    ?tgtEvent a owl:Class .
			    ?tgtEvent skos:prefLabel "event"@en .
			    ?tgtEvent skos:prefLabel "gebeurtenis"@nl .
			    ?tgtInformationObject a owl:Class .
			    ?tgtInformationObject skos:prefLabel "information object"@en .
			    ?tgtInformationObject skos:prefLabel "informatieobject"@nl .
			    ?tgtDocument a owl:Class .
			    ?tgtDocument skos:prefLabel "document"@en .
			    ?tgtDocument skos:prefLabel "document"@nl .
			    ?tgtDocument rdfs:subClassOf ?tgtInformationObject .
			    ?tgtFile a owl:Class .
			    ?tgtFile skos:prefLabel "file"@en .
			    ?tgtFile skos:prefLabel "file"@nl .
			    ?tgtFile rdfs:subClassOf ?tgtInformationObject .
			    ?tgtEnumerationType a owl:Class .
			    ?tgtEnumerationType skos:prefLabel "enumeration type"@en .
			    ?tgtEnumerationType skos:prefLabel "enumeratietype"@nl .
			    ?tgtState a owl:Class .
			    ?tgtState skos:prefLabel "state"@en .
			    ?tgtState skos:prefLabel "toestand"@nl .
			    nen2660:hasPart a owl:ObjectProperty .
			    nen2660:hasPart skos:prefLabel "has part"@en .
			    nen2660:hasPart skos:prefLabel "heeft onderdeel"@nl .
				?tgtMatter a owl:Class .
			    ?tgtMatter skos:prefLabel "matter"@en .
			    ?tgtMatter skos:prefLabel "materie"@nl .
				?tgtFunctionalSpace a owl:Class . 
				?tgtFunctionalSpace skos:prefLabel "Spatial region"@en . 
				?tgtFunctionalSpace skos:prefLabel "Ruimtelijk gebied"@nl . 
			}
			WHERE {
			    ?this a owl:Ontology .
				FILTER (!STRSTARTS(str(?this), "http://hub.laces.tech/semmtech/schemas")) .
                FILTER (!STRSTARTS(str(?this), "http://www.laces.tech/publication/ns/semmtech")) .
                #Filtering out contract manager and blueprint manager.
                FILTER (!STRSTARTS(str(?this), "http://models.laces.tech/")) .
				FILTER (!STRSTARTS(str(?this), "http://data.semmtech.com/sem/")) .
				FILTER (!STRSTARTS(str(?this), "http://www.w3.org/")) .

			    
				?this rdfs:label ?tgtOntologyName .
			    OPTIONAL { 
				?this dct:description ?tgtOntologyDescription .
			    ?this dct:date ?versionDate .
				BIND (REPLACE(?versionDate, "T[0-9]{2}:[0-9]{2}:[0-9]{2}.[0-9]{6}", "") AS ?tgtVersionDate) .
				}
			    BIND (ex:createURI("") AS ?tgtInferredOntology) .
			    # BIND (nen2660:GeometricEntity AS ?tgtSpatialRegion) .
			    BIND (nen2660:RealObject AS ?tgtPhysicalObject) .
			    # BIND (nen2660:Activity AS ?tgtActivity) .
			    # BIND (nen2660:Event AS ?tgtEvent) .
			    BIND (nen2660:InformationObject AS ?tgtInformationObject) .
			    BIND (nen2660:EnumerationType AS ?tgtEnumerationType) .
			    # BIND (nen2660:State AS ?tgtState) .
				# BIND (nen2660:Matter AS ?tgtMatter) .
				BIND (nen2660:SpatialRegion AS ?tgtFunctionalSpace ) . 
			}
			""" ;
            sh:deactivated false ;
            sh:prefixes ex:,
                dct:,
                bm:,
                otl:,
                shapes:,
                rdf:,
                rdfs:,
                xsd:,
                owl:,
                skos:,
                sh:,
                schema:,
                nen2660: ] ;
    sh:targetClass owl:Ontology .

ex:createHumanReadableUri a sh:SPARQLFunction ;
    sh:parameter [ sh:datatype xsd:string ;
            sh:description "The label that will be used for the Uri" ;
            sh:path ex:op1 ] ;
    sh:prefixes ex:,
        dct:,
        rdfs:,
        owl: ;
    sh:returnType rdfs:Resource ;
    sh:select """
		SELECT ?uri
		WHERE {	
			?namespace a owl:Ontology .
			FILTER (!STRSTARTS(str(?namespace), "http://hub.laces.tech/semmtech/schemas")) .
			FILTER (!STRSTARTS(str(?namespace), "http://www.laces.tech/publication/ns/semmtech")) .
			#Filtering out contract manager and blueprint manager.
			FILTER (!STRSTARTS(str(?namespace), "http://models.laces.tech/")) .
			FILTER (!STRSTARTS(str(?namespace), "http://data.semmtech.com/sem/")) .
			FILTER (!STRSTARTS(str(?namespace), "http://www.w3.org/")) .
 
			?namespace rdfs:label ?ontologyName . # This one also does nothing, but can be left in. 

			BIND (ex:humanReadableNameForUri($op1, $op1) AS ?nameCamelCase) .
			BIND (STR(ENCODE_FOR_URI(?nameCamelCase))  AS ?nameEncoded) . 
			BIND (URI(CONCAT(STR(?namespace),  str(?nameEncoded))) AS ?uri) .
		}
		LIMIT 1
		""" .

ex:createURI a sh:SPARQLFunction ;
    sh:parameter [ sh:datatype xsd:string ;
            sh:description "The first operand" ;
            sh:path ex:op1 ] ;
    sh:prefixes ex:,
        dct:,
        rdfs:,
        owl: ;
    sh:returnType rdfs:Resource ;
    sh:select """
		SELECT ?uri
		WHERE {	
			?namespace a owl:Ontology .
			FILTER (!STRSTARTS(str(?namespace), "http://hub.laces.tech/semmtech/schemas")) .
			FILTER (!STRSTARTS(str(?namespace), "http://www.laces.tech/publication/ns/semmtech")) .
			#Filtering out contract manager and blueprint manager.
			FILTER (!STRSTARTS(str(?namespace), "http://models.laces.tech/")) .
			FILTER (!STRSTARTS(str(?namespace), "http://data.semmtech.com/sem/")) .
			FILTER (!STRSTARTS(str(?namespace), "http://www.w3.org/")) .
 
			?namespace rdfs:label ?ontologyName . # This one also does nothing, but can be left in.  

			BIND (URI(CONCAT(STR(?namespace),  str($op1))) AS ?uri) .
		}
		LIMIT 1
		""" .

ex:humanReadableNameForUri a sh:SPARQLFunction ;
    sh:parameter [ sh:datatype xsd:string ;
            sh:description "The original label in its entirety" ;
            sh:path ex:op1 ],
        [ sh:datatype xsd:string ;
            sh:description "The part of the label that needs to be processed" ;
            sh:path ex:op2 ] ;
    sh:prefixes ex:,
        dct:,
        rdfs:,
        owl: ;
    sh:returnType rdfs:Resource ;
    sh:select """
		SELECT ?tgtLabel
		WHERE {	
			### How it works
			## 1st iteration
			# op1: this is a test
			# op2: this is a test
			# processedPartCamelCase: this
			# toBeProcessed: is a test

			## 2nd iteration
			# op1: this is a test
			# op2: is a test
			# processedPartCamelCase: Is
			# toBeProcessed: a test

			# after final iteration it loops back to concatenate the values for ?processedPartCamelCase

			BIND (IF(CONTAINS($op1, " "), STRBEFORE($op1, " "), $op1) AS ?lowercasePart) .
			BIND (IF(CONTAINS($op2, " "), STRBEFORE($op2, " "), $op2) AS ?processedPart) .
			BIND (IF(?processedPart = ?lowercasePart, ?processedPart, CONCAT(UCASE(SUBSTR(?processedPart, 1, 1)), LCASE(SUBSTR(?processedPart, 2)))) AS ?processedPartCamelCase) .
			BIND (IF(CONTAINS($op2, " "), STRAFTER($op2, " "), 1/0) AS ?toBeProcessed) .

			BIND (IF(BOUND(?toBeProcessed), CONCAT(?processedPartCamelCase, ex:humanReadableNameForUri($op1, ?toBeProcessed)),  ?processedPartCamelCase) AS ?tgtLabel) .
		}
		LIMIT 1
		""" .

ex:localname a sh:SPARQLFunction ;
    sh:parameter [ sh:datatype xsd:string ;
            sh:description "The first operand" ;
            sh:path ex:op1 ] ;
    sh:prefixes ex: ;
    sh:returnType rdfs:Resource ;
    sh:select """
		SELECT ?localname
		WHERE {
			BIND (IF(CONTAINS(str($op1), "#"), STRAFTER(str($op1), "#"), REPLACE(str($op1), "(.*)[//]", "")) AS ?localname) .
		}
		""" .

kos: sh:declare [ sh:namespace "http://www.laces.tech/publication/ns/semmtech/live/laces/schema/kos/"^^xsd:anyURI ;
            sh:prefix "kos" ] .

kos:IndividualActivity rdfs:seeAlso nen2660:Activity .

kos:IndividualAgent skos:altLabel "Agent" .

kos:IndividualDocument skos:altLabel "Document" .

kos:IndividualFunction skos:altLabel "Function" .

kos:IndividualObject rdfs:seeAlso nen2660:RealObject .

kos:IndividualObjective skos:altLabel "Objective" .

kos:IndividualSpace skos:altLabel "Space" .

otl:Activity rdfs:seeAlso nen2660:Activity .

otl:Activity-isLocatedAt-GeometricalSpace rdfs:seeAlso nen2660:hasInterior .

otl:Document rdfs:seeAlso nen2660:InformationObject .

otl:Event rdfs:seeAlso nen2660:Event .

otl:FunctionalSpace-isLocatedAt-GeometricalSpace rdfs:seeAlso nen2660:hasInterior .

otl:GeometricalSpace rdfs:seeAlso nen2660:GeometricEntity .

otl:Matter rdfs:seeAlso nen2660:Matter .

otl:PhysicalObject rdfs:seeAlso nen2660:RealObject .

otl:PhysicalObject-isLocatedAt-GeometricalSpace rdfs:seeAlso nen2660:hasInterior .

otl:State rdfs:seeAlso nen2660:State .

otl:TimePeriod rdfs:seeAlso nen2660:TemporalEntity .

otl:consistsOf rdfs:seeAlso nen2660:consistsOf .

otl:describes owl:inverseOf nen2660:isDescribedBy .

otl:hasAsSubject skos:altLabel "hasAsSubject" .

otl:hasState rdfs:seeAlso nen2660:hasState .

otl:isAccountableFor skos:altLabel "isAccountableFor" .

otl:isApproverOf skos:altLabel "isApproverOf" .

otl:isAuthorOf skos:altLabel "isAuthorOf" .

otl:isConnectedTo rdfs:seeAlso nen2660:isConnectedTo .

otl:isConsultedFor skos:altLabel "isConsultedFor" .

otl:isFulfillerOf skos:altLabel "isFulfillerOf" .

otl:isInformedFor skos:altLabel "isInformedFor" .

otl:isInputOf skos:altLabel "isInputOf" .

otl:isLocatedAt owl:inverseOf nen2660:contains .

otl:isOutputOf skos:altLabel "isOutputOf" .

otl:isPerformerOf rdfs:seeAlso nen2660:executes ;
    skos:altLabel "isPerformerOf" .

otl:isReleaserOf skos:altLabel "isReleaserOf" .

otl:isResponsibleFor skos:altLabel "isResponsibleFor" .

otl:isSupportiveFor skos:altLabel "isSupportiveFor" .

otl:transforms rdfs:seeAlso nen2660:transforms ;
    skos:altLabel "transforms" .

specifications: sh:declare [ sh:namespace "http://www.laces.tech/publication/ns/semmtech/live/laces/schema/specifications/"^^xsd:anyURI ;
            sh:prefix "specifications" ] .

bs: sh:declare [ sh:namespace "https://w3id.org/def/basicsemantics-owl#"^^xsd:anyURI ;
            sh:prefix "bs" ] .

otl:FunctionalSpace rdfs:seeAlso nen2660:SpatialRegion .

geo: sh:declare [ sh:namespace "http://www.opengis.net/ont/geosparql#"^^xsd:anyURI ;
            sh:prefix "geo" ] .

dct: sh:declare [ sh:namespace "http://purl.org/dc/terms/"^^xsd:anyURI ;
            sh:prefix "dct" ] .

bm: sh:declare [ sh:namespace "http://www.laces.tech/publication/ns/semmtech/live/laces/schema/blueprint-manager/"^^xsd:anyURI ;
            sh:prefix "bm" ] .

shapes: sh:declare [ sh:namespace "http://www.laces.tech/publication/ns/semmtech/live/laces/schema/shapes/"^^xsd:anyURI ;
            sh:prefix "shapes" ] .

rdf: sh:declare [ sh:namespace "http://www.w3.org/1999/02/22-rdf-syntax-ns#"^^xsd:anyURI ;
            sh:prefix "rdf" ] .

xsd: sh:declare [ sh:namespace "http://www.w3.org/2001/XMLSchema#"^^xsd:anyURI ;
            sh:prefix "xsd" ] .

skos: sh:declare [ sh:namespace "http://www.w3.org/2004/02/skos/core#"^^xsd:anyURI ;
            sh:prefix "skos" ] .

schema: sh:declare [ sh:namespace "https://schema.org/"^^xsd:anyURI ;
            sh:prefix "schema" ] .

nen2660: sh:declare [ sh:namespace "https://w3id.org/nen2660/def#"^^xsd:anyURI ;
            sh:prefix "nen2660" ] .

otl: sh:declare [ sh:namespace "http://www.laces.tech/publication/ns/semmtech/live/laces/schema/otl-manager/"^^xsd:anyURI ;
            sh:prefix "otl" ] .

sh: sh:declare [ sh:namespace "http://www.w3.org/ns/shacl#"^^xsd:anyURI ;
            sh:prefix "sh" ] .

owl: sh:declare [ sh:namespace "http://www.w3.org/2002/07/owl#"^^xsd:anyURI ;
            sh:prefix "owl" ] .

rdfs: sh:declare [ sh:namespace "http://www.w3.org/2000/01/rdf-schema#"^^xsd:anyURI ;
            sh:prefix "rdfs" ] .

ex: sh:declare [ sh:namespace "http://example.org/example#"^^xsd:anyURI ;
            sh:prefix "ex" ] .

